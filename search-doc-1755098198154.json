{"searchDocs":[{"title":"Alternatives","type":0,"sectionRef":"#","url":"/scala-hedgehog/docs/alternatives","content":"","keywords":"","version":"Next"},{"title":"Alternatives​","type":1,"pageTitle":"Alternatives","url":"/scala-hedgehog/docs/alternatives#alternatives","content":" In Scala there are other property-testing alternatives:  https://github.com/typelevel/scalacheck The original port of QuickCheck in Scala. https://zio.dev/docs/usecases/usecases_testing A testing library build on ZIO that includes integrated shrinking. https://github.com/adamgfraser/unveiling-zio-test/blob/master/unveiling-zio-test.pdfhttps://github.com/zio/zio/tree/master/test/shared/src/main/scala/zio/test https://github.com/melrief/sonic This is another port of Hedgehog, based on cats and monix. https://github.com/scalaprops/scalaprops Makes some improvements on the ScalaCheck implementation. https://github.com/japgolly/nyaya Another fast data generator and property testing library in Scala. ","version":"Next","tagName":"h2"},{"title":"Hedgehog for Scala","type":0,"sectionRef":"#","url":"/scala-hedgehog/docs/","content":"","keywords":"","version":"Next"},{"title":"Hedgehog​","type":1,"pageTitle":"Hedgehog for Scala","url":"/scala-hedgehog/docs/#hedgehog","content":"   Project\tMaven Central\tMaven Central (JS)hedgehog-core hedgehog-runner hedgehog-sbt hedgehog-minitest hedgehog-munit   Supported Scala Versions: 2.12, 2.13 and 3.3+  Hedgehog will eat all your bugs.    Hedgehog is a modern property-based testing system, in the spirit of QuickCheck (and ScalaCheck). Hedgehog uses integrated shrinking, so shrinks obey the invariants of generated values by construction.  Current StatusFeaturesGetting Started SBT Binary DependencySBT Source DependencySBT TestingIntelliJ ExampleGuides TutorialState TutorialState Tutorial - VarsMigration from ScalaCheckDifferences to Haskell Hedgehog Motivation Design Considerations ResourcesAlternativesIntegration with other test libraries MinitestMUnit  ","version":"Next","tagName":"h2"},{"title":"Current Status​","type":1,"pageTitle":"Hedgehog for Scala","url":"/scala-hedgehog/docs/#current-status","content":" This project is still in some form of early release. The API may break during this stage until (if?) there is a wider adoption.  Please drop us a line if you start using scala-hedgehog in anger, we'd love to hear from you.  ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"Hedgehog for Scala","url":"/scala-hedgehog/docs/#features","content":" Integrated shrinking, shrinks obey invariants by construction.Abstract state machine testing.Range combinators for full control over the scope of generated numbers and collections.SBT test runnerCurrently no external dependencies in the core module ","version":"Next","tagName":"h2"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/scala-hedgehog/docs/getting-started","content":"","keywords":"","version":"Next"},{"title":"Getting Started​","type":1,"pageTitle":"Getting Started","url":"/scala-hedgehog/docs/getting-started#getting-started","content":" ","version":"Next","tagName":"h2"},{"title":"SBT Binary Dependency​","type":1,"pageTitle":"Getting Started","url":"/scala-hedgehog/docs/getting-started#sbt-binary-dependency","content":" In your build.sbt, add the following libraryDependencies.  val hedgehogVersion = &quot;0.13.0&quot; libraryDependencies ++= Seq( &quot;qa.hedgehog&quot; %% &quot;hedgehog-core&quot; % hedgehogVersion, &quot;qa.hedgehog&quot; %% &quot;hedgehog-runner&quot; % hedgehogVersion, &quot;qa.hedgehog&quot; %% &quot;hedgehog-sbt&quot; % hedgehogVersion ).map(_ % Test)   Supported Scala Versions: 2.12, 2.13 and 3.3+  ","version":"Next","tagName":"h3"},{"title":"SBT Source Dependency​","type":1,"pageTitle":"Getting Started","url":"/scala-hedgehog/docs/getting-started#sbt-source-dependency","content":" This project can be added as an SBT subproject.  // This can also be a branch name, like 'master'`, if you want to live on the edge val hedgehogVersion = &quot;${COMMIT}&quot; val hedgehogUri = uri(&quot;https://github.com/hedgehogqa/scala-hedgehog.git#&quot; + hedgehogVersion) lazy val root = (project in file(&quot;.&quot;)) .dependsOn(ProjectRef(hedgehogUri, &quot;core&quot;)) .dependsOn(ProjectRef(hedgehogUri, &quot;runner&quot;)) .dependsOn(ProjectRef(hedgehogUri, &quot;sbt-test&quot;))   NOTE: Depending on your scala version(s) SBT might not resolve.  ","version":"Next","tagName":"h3"},{"title":"SBT Testing​","type":1,"pageTitle":"Getting Started","url":"/scala-hedgehog/docs/getting-started#sbt-testing","content":" Scala Hedgehog comes with a very primitive runner interface, and supports theSBT testing extension.  NOTE If you're using sbt version 1.9.0 or lower, you need to add the following line to your build.sbt file: testFrameworks += TestFramework(&quot;hedgehog.sbt.Framework&quot;)   NOTE For sbt version 1.9.1 or higher, this step is not necessary, as Hedgehog is supported by default.  ","version":"Next","tagName":"h3"},{"title":"IntelliJ​","type":1,"pageTitle":"Getting Started","url":"/scala-hedgehog/docs/getting-started#intellij","content":" The IntelliJ scala plugin only hashard-coded support for the most popular test frameworks. While Hedgehog is obviously not included in that list, an may never be, by extending the runnerProperties tests can be run as an application (as Properties includes a handy main function). NOTE: This requires the test to be an object and not a class.  ","version":"Next","tagName":"h3"},{"title":"Example​","type":1,"pageTitle":"Getting Started","url":"/scala-hedgehog/docs/getting-started#example","content":" See the examples module for working versions.  import hedgehog._ import hedgehog.runner._ object PropertyTest extends Properties { def tests: List[Test] = List( property(&quot;reverse&quot;, testReverse) ) def testReverse: Property = for { xs &lt;- Gen.alpha.list(Range.linear(0, 100)).forAll } yield xs.reverse.reverse ==== xs }   ","version":"Next","tagName":"h2"},{"title":"Guides​","type":1,"pageTitle":"Getting Started","url":"/scala-hedgehog/docs/getting-started#guides","content":" Guides ","version":"Next","tagName":"h2"},{"title":"Differences to Haskell Hedgehog","type":0,"sectionRef":"#","url":"/scala-hedgehog/docs/guides-haskell-differences","content":"","keywords":"","version":"Next"},{"title":"Differences to Haskell Hedgehog​","type":1,"pageTitle":"Differences to Haskell Hedgehog","url":"/scala-hedgehog/docs/guides-haskell-differences#differences-to-haskell-hedgehog","content":" This page documents where the Scala Hedgehog API deviates significantly from the Haskell version.  Result Property Plus Example Monadic GenState Vars  ","version":"Next","tagName":"h2"},{"title":"Result​","type":1,"pageTitle":"Differences to Haskell Hedgehog","url":"/scala-hedgehog/docs/guides-haskell-differences#result","content":" The Haskell version allow for assertions throughout the Property monad, but the final value is().  prop_reverse :: Property prop_reverse = property $ do xs &lt;- forAll $ Gen.list (Range.linear 0 100) Gen.alpha reverse (reverse xs) === xs   And the corresponding Scala version:  def propReverse: Property = for { xs &lt;- Gen.alpha.list(Range.linear(0, 100)).forAll } yield xs.reverse.reverse ==== xs   ","version":"Next","tagName":"h2"},{"title":"Resource Management​","type":1,"pageTitle":"Differences to Haskell Hedgehog","url":"/scala-hedgehog/docs/guides-haskell-differences#resource-management","content":" This approach makes it more difficult to isolate resource management in a strict language like Scala. It then becomes fairly important in the Haskell version to useResourceT:  prop_unix_sort :: Property prop_unix_sort = property $ do values0 &lt;- forAll $ Gen.list (Range.linear 0 100) Gen.alpha test . runResourceT $ do dir &lt;- Temp.createTempDirectory Nothing &quot;prop_dir&quot; ... values0 === values   To simplify this, and to reduce surprises, the final result in the Scala version is now a separateResult value, which forces a single, final assertion to be returned.  def propUnixSort: Property = for { values0 &lt;- Gen.alpha.list(Range.linear(0, 100)).forAll } yield { val dir = java.io.Files.createTempDirectory(getClass.getSimpleName).toFile try { values0 ==== values } finally { dir.delete() } }   ","version":"Next","tagName":"h3"},{"title":"Property Plus Example​","type":1,"pageTitle":"Differences to Haskell Hedgehog","url":"/scala-hedgehog/docs/guides-haskell-differences#property-plus-example","content":" The Scala version has an additional data type that allows generators to be applied to the final &quot;test&quot; in a way that can be invoked from by consumers.  def propReverse: PropertyR[List[Char]] = PropertyR( Gen.alpha.list(Range.linear(0, 100)).forAll )(xs =&gt; xs.reverse.reverse ==== xs)   Here is an example of re-using the same method with both a property and a &quot;golden&quot; example test:   def tests: List[Test] = List( property(propReverse) , example(propReverse.test(List('a', 'b', 'c'))) )   ","version":"Next","tagName":"h3"},{"title":"Monadic Gen​","type":1,"pageTitle":"Differences to Haskell Hedgehog","url":"/scala-hedgehog/docs/guides-haskell-differences#monadic-gen","content":" One of the original goals of the Haskell implementation was to support completely generic monadic values.  Generators allow monadic effects.  For example you could use a StateT as part of the generator. In a strict language like Scala the Monad is alsocritical for providing a lazy tree. However, putting the laziness on each tree node results in serious memory problems. For now we have had to move this laziness to the tree children.  In practice I doubt that many people are seriously using monadic effects for generated values, and I'm happy to revisit this if/when an issue is raised.  ","version":"Next","tagName":"h2"},{"title":"State Vars​","type":1,"pageTitle":"Differences to Haskell Hedgehog","url":"/scala-hedgehog/docs/guides-haskell-differences#state-vars","content":" The Haskell State testing uses a very powerful Symbolic and Concrete types to represent the different states of a variable when implementing the Command interface.  While this is technically possible in Scala, the types are quite intimidating, especially HTraversable. Instead we opt for a lower-level variable &quot;lookup&quot; by passing in the Environment map where concrete variables are available, so that users can resolve them manually. ","version":"Next","tagName":"h2"},{"title":"Migration From ScalaCheck","type":0,"sectionRef":"#","url":"/scala-hedgehog/docs/guides-migration-from-scalacheck","content":"","keywords":"","version":"Next"},{"title":"Migration From ScalaCheck​","type":1,"pageTitle":"Migration From ScalaCheck","url":"/scala-hedgehog/docs/guides-migration-from-scalacheck#migration-from-scalacheck","content":" For many cases migrating from ScalaCheck to Hedgehog should be fairlystraight forward, as the general principals are quite similar, and the changes are largely syntactic.  PropertiesGenArbitrary  ","version":"Next","tagName":"h2"},{"title":"Properties​","type":1,"pageTitle":"Migration From ScalaCheck","url":"/scala-hedgehog/docs/guides-migration-from-scalacheck#properties","content":" Some basic rules:  Replace Properties(&quot;...&quot;) with just PropertiesReplace Prop.forAll with a call to forAll on a specific Gen instance If you have previously been relying on Arbitrary instances these haveto be replaced with calls to functions that return an instance of Gen. See the extra package for some stand Scala data type combinators. For more information see the section on Gen. flatMap over the result of your genFoo.forAll, or use a forcomprehension.Return your Prop or Boolean assetions with Result.assert(...)Replace label or :| with Result.log(...)Replace equality assertions like ?= with ====  ","version":"Next","tagName":"h2"},{"title":"ScalaCheck​","type":1,"pageTitle":"Migration From ScalaCheck","url":"/scala-hedgehog/docs/guides-migration-from-scalacheck#scalacheck","content":" import org.scalacheck._ object StringSpecification extends Properties(&quot;String&quot;) { property(&quot;startsWith&quot;) = Prop.forAll { (a: String, b: String) =&gt; (a+b).startsWith(a) } }   ","version":"Next","tagName":"h3"},{"title":"Hedgehog​","type":1,"pageTitle":"Migration From ScalaCheck","url":"/scala-hedgehog/docs/guides-migration-from-scalacheck#hedgehog","content":" import hedgehog._ import hedgehog.runner._ object StringSpecification extends Properties { override def tests: List[Test] = List( property(&quot;startsWith&quot;, for { a &lt;- Gen.string(Gen.unicode, Range.linear(0, 100)).forAll b &lt;- Gen.string(Gen.unicode, Range.linear(0, 100)).forAll } yield Result.assert((a+b).startsWith(a)) ) ) }   ","version":"Next","tagName":"h3"},{"title":"Gen​","type":1,"pageTitle":"Migration From ScalaCheck","url":"/scala-hedgehog/docs/guides-migration-from-scalacheck#gen","content":" Some basic rules:  Gen.list and Gen.listOfN can be replaced with a call tolist(Range.linear(0, n)) on a specific Gen instance.Gen.const is now Gen.constantArbitrary.arbitrary[Int] is now Gen.int(Range.linear(min, max))Gen.oneOf is now Gen.choice1  It's important to note that there are no more &quot;default&quot; Arbitrary instances to summon. You must decided what kind of int or String you want to generate, and what their Range is.  ","version":"Next","tagName":"h2"},{"title":"ScalaCheck​","type":1,"pageTitle":"Migration From ScalaCheck","url":"/scala-hedgehog/docs/guides-migration-from-scalacheck#scalacheck-1","content":" val genLeaf = Gen.const(Leaf) val genNode = for { v &lt;- arbitrary[Int] left &lt;- genTree right &lt;- genTree } yield Node(left, right, v) def genTree: Gen[Tree] = Gen.oneOf(genLeaf, genNode)   ","version":"Next","tagName":"h3"},{"title":"Hedgehog​","type":1,"pageTitle":"Migration From ScalaCheck","url":"/scala-hedgehog/docs/guides-migration-from-scalacheck#hedgehog-1","content":" val genLeaf = Gen.constant(Leaf) val genNode = for { v &lt;- Gen.int(Range.linear(Integer.MaxValue, Integer.MinValue)) left &lt;- genTree right &lt;- genTree } yield Node(left, right, v) def genTree: Gen[Tree] = Gen.choice1(genLeaf, genNode)   ","version":"Next","tagName":"h3"},{"title":"Arbitrary​","type":1,"pageTitle":"Migration From ScalaCheck","url":"/scala-hedgehog/docs/guides-migration-from-scalacheck#arbitrary","content":" Some basic rules:  Replace implict def functions that return Arbitrary to a function that returns the Gen directly.  ","version":"Next","tagName":"h2"},{"title":"ScalaCheck​","type":1,"pageTitle":"Migration From ScalaCheck","url":"/scala-hedgehog/docs/guides-migration-from-scalacheck#scalacheck-2","content":" This example was taken from the ScalaCheck Guide.  implicit def arbTree[T](implicit a: Arbitrary[T]): Arbitrary[Tree[T]] = Arbitrary { val genLeaf = for(e &lt;- Arbitrary.arbitrary[T]) yield Leaf(e) def genInternal(sz: Int): Gen[Tree[T]] = for { n &lt;- Gen.choose(sz/3, sz/2) c &lt;- Gen.listOfN(n, sizedTree(sz/2)) } yield Internal(c) def sizedTree(sz: Int) = if(sz &lt;= 0) genLeaf else Gen.frequency((1, genLeaf), (3, genInternal(sz))) Gen.sized(sz =&gt; sizedTree(sz)) }   def genTree[T](g: Gen[T]): Gen[Tree[T]] = { val genLeaf = for(e &lt;- g) yield Leaf(e) def genInternal(sz: Size): Gen[Tree[T]] = for { n &lt;- Gen.choose(sz.value/3, sz.value/2) c &lt;- sizedTree(sz.value/2).list(Range.linear(0, n)) } yield Internal(c) def sizedTree(sz: Size) = if(sz.value &lt;= 0) genLeaf else Gen.frequency1((1, genLeaf), (3, genInternal(sz))) Gen.sized(sz =&gt; sizedTree(sz)) }   ","version":"Next","tagName":"h3"},{"title":"Shrink​","type":1,"pageTitle":"Migration From ScalaCheck","url":"/scala-hedgehog/docs/guides-migration-from-scalacheck#shrink","content":" This is assuming you're even writing them in the first place...  ","version":"Next","tagName":"h2"},{"title":"ScalaCheck​","type":1,"pageTitle":"Migration From ScalaCheck","url":"/scala-hedgehog/docs/guides-migration-from-scalacheck#scalacheck-3","content":" case class Data(a: String, i: Int) implicit def arbData: Arbitrary[Data] = Arbitrary[Data] { for { s &lt;- arbitrary[String] i &lt;- arbitrary[Int] } yield Data(a, i) } implicit def shrink: Shrink[Data] = Shrink[Data] { case Data(a, i) =&gt; shrink(a).map(a2 =&gt; Data(a2, i)) append shrink(i).map(i2 =&gt; Data(a, i2)) }   ","version":"Next","tagName":"h3"},{"title":"Hedgehog​","type":1,"pageTitle":"Migration From ScalaCheck","url":"/scala-hedgehog/docs/guides-migration-from-scalacheck#hedgehog-2","content":" Good news, you don't need to do anything! Just write your generators.  def genData: Gen[Data] = for { s &lt;- Gen.string(Gen.unicode, Range.linear(0, 100)) i &lt;- Gen.int(Range.linear(-100, 100)) } yield Data(a, i)  ","version":"Next","tagName":"h3"},{"title":"State-Based Property Testing Tutorial (Part 2 - Vars)","type":0,"sectionRef":"#","url":"/scala-hedgehog/docs/guides-state-tutorial-vars","content":"","keywords":"","version":"Next"},{"title":"State-Based Property Testing Tutorial (Part 2 - Vars)​","type":1,"pageTitle":"State-Based Property Testing Tutorial (Part 2 - Vars)","url":"/scala-hedgehog/docs/guides-state-tutorial-vars#state-based-property-testing-tutorial-part-2---vars","content":" This tutorial continues on from the first tutorial.  ","version":"Next","tagName":"h2"},{"title":"Follow Along​","type":1,"pageTitle":"State-Based Property Testing Tutorial (Part 2 - Vars)","url":"/scala-hedgehog/docs/guides-state-tutorial-vars#follow-along","content":" Please feel to play along and tinker with the code.  $ ./sbt &gt; example/runMain hedgehog.examples.state.CRTest   ","version":"Next","tagName":"h2"},{"title":"The Problem​","type":1,"pageTitle":"State-Based Property Testing Tutorial (Part 2 - Vars)","url":"/scala-hedgehog/docs/guides-state-tutorial-vars#the-problem","content":" To start with let's define an interface/abstraction for something we want to test against, part of a basic create/read/update/delete or CRUD store, which I'm calling CR as we only support create/read to simplify the example:  trait CR { def create(v: String): CRId def read(id: CRId): Option[String] } case class CRId(render: String)   NOTE: The big difference here from the previous KV is that the service is returning it's own identifier instead of being passed on. That has implications for testing the state with Hedgehog, which require something extra...  ","version":"Next","tagName":"h2"},{"title":"Model (take 1)​","type":1,"pageTitle":"State-Based Property Testing Tutorial (Part 2 - Vars)","url":"/scala-hedgehog/docs/guides-state-tutorial-vars#model-take-1","content":" Similar to our previous example, this also seems fairly straight forward. But we're about to hit a snag...  case class State(map: Map[CRId, String])   And our command input types:  case class Create(value: String) case class Read(id: CRId)   Now let's step throught the Command functions for create/read like before:  ","version":"Next","tagName":"h3"},{"title":"Gen​","type":1,"pageTitle":"State-Based Property Testing Tutorial (Part 2 - Vars)","url":"/scala-hedgehog/docs/guides-state-tutorial-vars#gen","content":" Generation is fairly typical. Note that we can't really usefully create aRead value until we have at least one value in State.  def gen(s: State): Option[Gen[Create]] = Some(for { v &lt;- Gen.string(Gen.ascii, Range.linear(1, 10)) } yield Create(v)) def gen(s: State): Option[Gen[Read]] = s.map.keys.toList match { case Nil =&gt; // We haven't created anything yet None case h :: t =&gt; Some(Gen.element(h, t).map(Read(_))) }   ","version":"Next","tagName":"h3"},{"title":"Execute (take 1)​","type":1,"pageTitle":"State-Based Property Testing Tutorial (Part 2 - Vars)","url":"/scala-hedgehog/docs/guides-state-tutorial-vars#execute-take-1","content":" So far everything lines up just like before:  def execute(i: Create): Either[String, CRId] = Right(cr.create(i.key, i.value)) def execute(i: Read): Either[String, Option[String]] = Right(cr.read(i.key))   ","version":"Next","tagName":"h3"},{"title":"Update​","type":1,"pageTitle":"State-Based Property Testing Tutorial (Part 2 - Vars)","url":"/scala-hedgehog/docs/guides-state-tutorial-vars#update","content":" def update(s: State, i: Create, o: Var[CRId]): State = s.copy(map = s.map + (o -&gt; i.value)) // There are no side-effects for get, so nothing to do def update(s: State, i: Read): State = s   Hang on, what's that Var[CRid] doing?!? Why isn't it just a concrete CRId? That code doesn't even compile!  ","version":"Next","tagName":"h3"},{"title":"WTF​","type":1,"pageTitle":"State-Based Property Testing Tutorial (Part 2 - Vars)","url":"/scala-hedgehog/docs/guides-state-tutorial-vars#wtf","content":" It turns out that Hedgehog forces a very clear separation for functions that can access the &quot;real world&quot; state, and those that can't. The reasons for this are a little involved, but the basic idea is that we can generate a full sequence of commands up-front, without having called execute. So the question/problem then becomes, how do we capture the &quot;result&quot; to be used ingen, like we need to do for read?  This is where Var and Environment come in. For each Command.execute, Hedgehog allocates a unique Name (just a plain old incrementing Int), and passed that to the &quot;pure&quot; functions, like update and gen. It's only when we need the concrete values do we get access to the Environment to look them up.  Here is the relevant data types, that should hopefully make more sense now?  case class Name(value: Int) case class Environment(map: Map[Name, Any]) case class Var[A](name: Name) { def get(env: Env): A = env.map(name) }   ","version":"Next","tagName":"h3"},{"title":"Model (take 2)​","type":1,"pageTitle":"State-Based Property Testing Tutorial (Part 2 - Vars)","url":"/scala-hedgehog/docs/guides-state-tutorial-vars#model-take-2","content":" So we will need to tweak our model and input slightly to use Var:  case class State(map: Map[Var[CRId], String]) case class Read(id: Var[CRId])   ","version":"Next","tagName":"h3"},{"title":"Execute (take 2)​","type":1,"pageTitle":"State-Based Property Testing Tutorial (Part 2 - Vars)","url":"/scala-hedgehog/docs/guides-state-tutorial-vars#execute-take-2","content":" So let's try that again. Note that we now use Environment in the Readversion to get the concrete CRId returned from create.  def execute(env: Environment, i: Create): Either[String, CRId] = Right(cr.create(i.key, i.value)) def execute(env: Environment, i: Read): Either[String, Option[String]] = Right(cr.read(i.key.get(env)))   ","version":"Next","tagName":"h3"},{"title":"Ensure​","type":1,"pageTitle":"State-Based Property Testing Tutorial (Part 2 - Vars)","url":"/scala-hedgehog/docs/guides-state-tutorial-vars#ensure","content":" This is identical to KV, although notice we could use Environment here if we needed to, unlike update.  // Almost the reverse of update, for side-effect operations we may not observe anything just yet def ensure(env: Environment, s0: State, s1: State, i: Create, o: CRId): Result = Result.success def ensure(env: Environment, s0: State, s1: State, i: Read, o: Option[String]): Result = s1.map.get(i.key) ==== o   ","version":"Next","tagName":"h3"},{"title":"Debugging​","type":1,"pageTitle":"State-Based Property Testing Tutorial (Part 2 - Vars)","url":"/scala-hedgehog/docs/guides-state-tutorial-vars#debugging","content":" Let's look at the output of a failed test again:  Var(Name(0)) = Create(a) Var(Name(1)) = Create(b) Var(Name(2)) = Read(Var(Name(0)))   We can start to see that each command is shown to be assigning the result to a new, unique Var. We aren't looking at the actual CRId values. Hedgehog (currently) can't tell that Read doesn't actually return anything (useful) and so the Unit value is also asigned to a new Var.  ","version":"Next","tagName":"h2"},{"title":"Resources​","type":1,"pageTitle":"State-Based Property Testing Tutorial (Part 2 - Vars)","url":"/scala-hedgehog/docs/guides-state-tutorial-vars#resources","content":" Unfortunately there isn't much documentation for this approach at the moment.  Finding Race Conditions in Erlang with QuickCheck and PULSEHedgehog follows a vague description of this implementation which is mentioned in this paper.State machine testing with HedgehogHaskell Differences ","version":"Next","tagName":"h2"},{"title":"Guides","type":0,"sectionRef":"#","url":"/scala-hedgehog/docs/guides/","content":"","keywords":"","version":"Next"},{"title":"Guides​","type":1,"pageTitle":"Guides","url":"/scala-hedgehog/docs/guides/#guides","content":" TutorialState TutorialState Tutorial - VarsMigration from ScalaCheck ","version":"Next","tagName":"h2"},{"title":"Integration with Minitest","type":0,"sectionRef":"#","url":"/scala-hedgehog/docs/integration-minitest","content":"","keywords":"","version":"Next"},{"title":"Minitest​","type":1,"pageTitle":"Integration with Minitest","url":"/scala-hedgehog/docs/integration-minitest#minitest","content":" Scala Hedgehog provides an integration module for minitest. This allows you to define property-based and example-based Hedgehog tests within a minitest test suite. If you use this integration, you won't need to Scala Hedgehog sbt testing extension, because you're using the one provided by minitest:  val hedgehogVersion = &quot;0.13.0&quot; libraryDependencies += &quot;qa.hedgehog&quot; %% &quot;hedgehog-minitest&quot; % hedgehogVersion % Test   NOTE If you're using sbt version 1.9.0 or lower, you need to add the following line to your build.sbt file: testFrameworks += TestFramework(&quot;hedgehog.sbt.Framework&quot;)   NOTE For sbt version 1.9.1 or higher, this step is not necessary, as Hedgehog is supported by default.  Here's an example of using hedgehog-minitest:  import minitest.SimpleTestSuite import hedgehog.minitest.HedgehogSupport import hedgehog._ object ReverseTest extends SimpleTestSuite with HedgehogSupport { property(&quot;reverse alphabetic strings&quot;) { for { xs &lt;- Gen.alpha.list(Range.linear(0, 100)).forAll } yield xs.reverse.reverse ==== xs } example(&quot;reverse hello&quot;) { &quot;hello&quot;.reverse ==== &quot;olleh&quot; } }  ","version":"Next","tagName":"h2"},{"title":"Integration with MUnit","type":0,"sectionRef":"#","url":"/scala-hedgehog/docs/integration-munit","content":"","keywords":"","version":"Next"},{"title":"MUnit​","type":1,"pageTitle":"Integration with MUnit","url":"/scala-hedgehog/docs/integration-munit#munit","content":" Scala Hedgehog provides an integration module for munit. This allows you to define property-based and example-based Hedgehog tests within a munit test suite. If you use this integration, you won't need to Scala Hedgehog sbt testing extension, because you're using the one provided by munit:  val hedgehogVersion = &quot;0.13.0&quot; libraryDependencies += &quot;qa.hedgehog&quot; %% &quot;hedgehog-munit&quot; % hedgehogVersion % Test   NOTE If you're using sbt version 1.9.0 or lower, you need to add the following line to your build.sbt file: testFrameworks += TestFramework(&quot;hedgehog.sbt.Framework&quot;)   NOTE For sbt version 1.9.1 or higher, this step is not necessary, as Hedgehog is supported by default.  Here's an example of using hedgehog-munit:  import hedgehog.munit.HedgehogSuite import hedgehog._ class ReverseSuite extends HedgehogSuite { property(&quot;reverse alphabetic strings&quot;) { for { xs &lt;- Gen.alpha.list(Range.linear(0, 100)).forAll } yield assertEquals(xs.reverse.reverse, xs) } test(&quot;reverse hello&quot;) { withMunitAssertions{ assertions =&gt; assertions.assertEquals(&quot;hello&quot;.reverse, &quot;olleh&quot;) } &quot;hello&quot;.reverse ==== &quot;olleh&quot; } }   HedgehogSuite provides munit-like assertions, along with all the hedgehog.Result methods and members, that return results in the standard hedgehog report format while satisfying munit's exception-based test failures. ","version":"Next","tagName":"h2"},{"title":"Integration with other test libraries","type":0,"sectionRef":"#","url":"/scala-hedgehog/docs/integration/","content":"Integration with other test libraries Scala Hedgehog provides integration modules for MinitestMUnit","keywords":"","version":"Next"},{"title":"Resources","type":0,"sectionRef":"#","url":"/scala-hedgehog/docs/resources","content":"","keywords":"","version":"Next"},{"title":"Resources​","type":1,"pageTitle":"Resources","url":"/scala-hedgehog/docs/resources#resources","content":" Fortunately there is much in common across property-testing material, and as such the following are still relevant despite whatever language they are presented with.  ","version":"Next","tagName":"h2"},{"title":"Blogs​","type":1,"pageTitle":"Resources","url":"/scala-hedgehog/docs/resources#blogs","content":" intro to Hedgehog for Scala (eed3si9n.com)Choosing properties for property-based testing (sharpforfunandprofit.com)An introduction to property-based testing (sharpforfunandprofit.com)Integrated versus Manual Shrinking (well-typed.com)Property-Based Testing in a Screencast Editor (wickstrom.tech)  ","version":"Next","tagName":"h3"},{"title":"Presentations​","type":1,"pageTitle":"Resources","url":"/scala-hedgehog/docs/resources#presentations","content":" Much Ado About Testing - Nicolas Rinaudo at ScalaWorld 2019Introduction to stateful property based testing - Tomasz Kowal at Lambda Days 2019Building on Developers' Intuitions to Create Effective Property-Based Tests - John Hughes at Lambda Days 2019Property-Based Testing The Ugly Parts: Case Studies from Komposition - Oskar Wickström at flatMap (Oslo) 2019Types vs Tests - Julien Truffaut at Scala eXchange 2018Appetite for dysfunction - Andrew McCluskey at Compose Melbourne 2018Property-based State Machine Testing - Andrew McCluskey at YOW! Lambda Jam 2018.Gens N’ Roses: Appetite for Reduction - Jacob Stanley at YOW! Lambda Jam 2017.Find More Bugs with Less Effort - Charles O'Farrell at YOW! Night Singapore 2017.Property-based Testing in Practice - Alex Chan at QCon 2017.Functions and Determinism in Property-based Testing - Erik Osheim at Philly ETE 2017Practical Property-Based Testing - Charles O’Farrell at YOW! Lambda Jam 2015.Property-Based Testing for Better Code - Jessica Kerr at Midwest.io 2014.I Dream of Gen’ning: ScalaCheck Beyond the Basics - Kelsey Gilmore-Innis at Scala By The Bay 2014.Testing the Hard Stuff and Staying Sane - John Hughes on property-based testing using Quviq QuickCheck.Testing Stateful Systems with ScalaCheck - Rickard Nilsson at ScalaDays 2014.  ","version":"Next","tagName":"h3"},{"title":"Books​","type":1,"pageTitle":"Resources","url":"/scala-hedgehog/docs/resources#books","content":" Property-Based Testing in a Screencast Editor by Oskar Wickström (2019)Property-Based Testing with PropEr, Erlang, and Elixir by Fred Hebert (2018)ScalaCheck: The Definitive Guide by Rickard Nilsson (2014) ","version":"Next","tagName":"h3"},{"title":"Motivation","type":0,"sectionRef":"#","url":"/scala-hedgehog/docs/motivation","content":"","keywords":"","version":"Next"},{"title":"Motivation​","type":1,"pageTitle":"Motivation","url":"/scala-hedgehog/docs/motivation#motivation","content":" The background and motivation for Hedgehog in general is still best described by the original author in this excellent presenation:    Watch it on Youtube: Gens N’ Roses: Appetite for Reduction (slides)  A very quick summary is that the original QuickCheck and its derivatives (like ScalaCheck) separate the generation of data from the shrinking, which results in something that cannot be composed easily. It turns out it's fairly simple to combine them in a single data-type.  If you've used ScalaCheck before, it's exactly the same as writing your normal Gen functions, but now those generated value will shrink without any extra information. Magic!  ","version":"Next","tagName":"h2"},{"title":"Design Considerations​","type":1,"pageTitle":"Motivation","url":"/scala-hedgehog/docs/motivation#design-considerations","content":" As a general rule, the current Scala API is intended to be direct port ofhaskell-hedgehog, much likescalacheck was for QuickCheck. The idea being that people familiar with one of the libraries will be comfortable with the other. It also makes it easier not having to re-invent any wheels (or APIs). There will obviously be exceptions where Scala forces us to make a different trade-off. See haskell-differences for examples and more explanation. ","version":"Next","tagName":"h2"},{"title":"State-Based Property Testing Tutorial","type":0,"sectionRef":"#","url":"/scala-hedgehog/docs/guides-state-tutorial","content":"","keywords":"","version":"Next"},{"title":"State-Based Property Testing Tutorial​","type":1,"pageTitle":"State-Based Property Testing Tutorial","url":"/scala-hedgehog/docs/guides-state-tutorial#state-based-property-testing-tutorial","content":" ","version":"Next","tagName":"h2"},{"title":"Follow Along​","type":1,"pageTitle":"State-Based Property Testing Tutorial","url":"/scala-hedgehog/docs/guides-state-tutorial#follow-along","content":" Please feel to play along and tinker with the code.  $ ./sbt &gt; example/runMain hedgehog.examples.state.KVTest   ","version":"Next","tagName":"h2"},{"title":"The Problem​","type":1,"pageTitle":"State-Based Property Testing Tutorial","url":"/scala-hedgehog/docs/guides-state-tutorial#the-problem","content":" To start with let's define an interface/abstraction for something we want to test against, the most basic key/value store:  trait KV { def put(k: String, v: String): Unit def get(k: String): Option[String] }   Now let's write some normal property tests to test it:  def testPut(kv: KV): Property = for { k &lt;- genKey v &lt;- genValue } yield { kv.put(k, v) kv.get(k) ==== Some(v) } def testGetMissing(kv: KV): Property = for { v &lt;- genValue } yield { kv.get(k) ==== None }   So far so good. But do we think we have tested all the cases? Think about that for a second and let's see what happens...  We're looking at an interface with just two functions, but there are infinite ways in which we can interact with them. How well do are tests scale when we addone more function (ie delete)? Or ten?  What we really want to do is let our property testing library generate the interactions themselves!  ","version":"Next","tagName":"h2"},{"title":"Model​","type":1,"pageTitle":"State-Based Property Testing Tutorial","url":"/scala-hedgehog/docs/guides-state-tutorial#model","content":" At a conceptual level the idea with state-based testing is to &quot;model&quot; the real world with something pure (ie in memory). We then execute real commands against our system/api, and compare the result with what our model expects.    At the technical level the current approach to writing a state-based test is to implement a series of very specific functions for each operation or &quot;command&quot; you want to test.  Firstly let's create our pure domain model for testing. In this case it's trivial to think of a key-value store as an immutable Map.  case class State(map: Map[String, String])   For each command you quite often end up just reifying the function arguments in to a data type:  case class Put(key: String, value: String) case class Get(key: String)   For each command you need to implement the Command interface. This can look quite daunting so let's step through it:  def command(kv: KV): CommandIO[State] = new Command[State, Input, Output] { def gen(s: State): Option[Gen[Input]] def execute(i: Input): Either[String, Output] def update(s: State, i: Input): State def ensure(s0: State, s1: State, i: Input, o: Output): Result }   ","version":"Next","tagName":"h2"},{"title":"Gen​","type":1,"pageTitle":"State-Based Property Testing Tutorial","url":"/scala-hedgehog/docs/guides-state-tutorial#gen","content":" Firstly, we need to be able to generate random inputs to our command.  The key thing to note is that we take in the current state, which we might want to use to generate some values. There might be cases where no valid input can be generated. For example you need to call put before you can call get. One simple way to generate our operations would be something like:  def gen(s: State): Option[Gen[Put]] = Some(for { k &lt;- Gen.string(Gen.ascii, Range.linear(1, 10)) v &lt;- Gen.string(Gen.ascii, Range.linear(1, 10)) } yield Put(k, v)) def gen(s: State): Option[Gen[Get]] = Some(Gen.string(Gen.ascii, Range.linear(1, 10)) .map(Get(_)))   But how often do we generate the same keys in either case? Shouldn't we try to generate similar keys sometimes?  A slightly better attempt:  def genKey: Gen[String] = Gen.string(Gen.ascii, Range.linear(1, 10)) def gen(s: State): Option[Gen[Put]] = Some(for { k &lt;- s.map.keys.toList match { case Nil =&gt; genKey case h :: t =&gt; // Choice between known and unknown keys Gen.frequency1( 50 -&gt; genKey , 50 -&gt; Gen.element(h, t) ) } // Always generate a unique value v &lt;- Gen.string(Gen.ascii, Range.linear(1, 10)) } yield Put(k, v)) def gen(s: State): Option[Gen[Get]] = Some((s.map.keys.toList match { case Nil =&gt; genKey case h :: t =&gt; // Mostly get values we know to exist, but also try values that don't Gen.frequency1( 80 -&gt; Gen.element(h, t) , 20 -&gt; genKey ) }).map(Get(_)))   That's definitely a little more involved, but you can see we're getting a good spread of put/get values with known/duplicate and unknown keys. That should cover everything, which is a critical component of good property testing in general.  ","version":"Next","tagName":"h3"},{"title":"Execute​","type":1,"pageTitle":"State-Based Property Testing Tutorial","url":"/scala-hedgehog/docs/guides-state-tutorial#execute","content":" This is the easy bit, just call our operation. Note the lack of our model/state, you can also interact with the &quot;real world&quot;.  def execute(i: Put): Either[String, Unit] = Right(kv.put(i.key, i.value)) def execute(i: Get): Either[String, Option[String]] = Right(kv.get(i.key))   ","version":"Next","tagName":"h3"},{"title":"Update​","type":1,"pageTitle":"State-Based Property Testing Tutorial","url":"/scala-hedgehog/docs/guides-state-tutorial#update","content":" This is where we need to &quot;model&quot; what we expect that operation to do in our pure state.  def update(s: State, i: Put): State = s.copy(map = s.map + (i.key -&gt; i.value)) // There are no side-effects for get, so nothing to do def update(s: State, i: Get): State = s   ","version":"Next","tagName":"h3"},{"title":"Ensure​","type":1,"pageTitle":"State-Based Property Testing Tutorial","url":"/scala-hedgehog/docs/guides-state-tutorial#ensure","content":" This is the &quot;post condition&quot;. What did we expect to happen in the real world vs our model?  Just as a side note, the s0 means the state before update is run, and s1 is the current state. It's always possible, and fairly common, to just use s1 and the input value.  // Almost the reverse of update, for side-effect operations we may not observe anything just yet def ensure(s0: State, s1: State, i: Put, o: Unit): Result = Result.success def ensure(s0: State, s1: State, i: Get, o: Option[String]): Result = s1.map.get(i.key) ==== o   ","version":"Next","tagName":"h3"},{"title":"FAQ​","type":1,"pageTitle":"State-Based Property Testing Tutorial","url":"/scala-hedgehog/docs/guides-state-tutorial#faq","content":" The common question here is &quot;won't we just end up with two implementations&quot;? Yes and no. Obviously this is a trivial example. The model is so simple that we can actually have a 100% full re-implementation. This won't always be the case, we may only want to guarantee some invariants are true, but not the exact behaviour. Also remember that we haven't actually looked at the implementation of KV yet. It might be storing keys on files, or across the network with multiple copies. If there are any bugs in any of that code it's quite likely we will find it at some point.  ","version":"Next","tagName":"h2"},{"title":"Sequential​","type":1,"pageTitle":"State-Based Property Testing Tutorial","url":"/scala-hedgehog/docs/guides-state-tutorial#sequential","content":" So the final piece is to hook up all our commands to form a property. It would look something like this:  def testKVFileSequential: Property = { val root = File(&quot;tmpdir&quot;) // Create a simple file-system KV store val kv = KV.file(root) sequential( // The range of commands to generate Range.linear(1, 100) // Out initial state to be used for each test run , State(Map()) // The list of commands , List(putCommand, getCommand) // Any cleanup code for the real-world, which in this case is to delete the KV file root for each test run , () =&gt; root.delete() ) }   This can be added to Hedgehog like any other property:  override def tests: List[Test] = List( property(&quot;test file KV (sequential)&quot;, testKVFileSequential) )   Some errors that a naive file implementation found:  Invalid file path​  &gt; Var(Name(0)) = Put(???,b) &gt; Error thrown running execute: Invalid file path   The first set of line(s) are the series of commands that have been run in order (ignore Var for now). Everything after that is our Result log.  So I'm generating invalid keys. So there is some restrictions on what our keys can be. Interesting. For now update the generator to something much more restrictive.  Note that this would have been found pretty quickly by our &quot;normal&quot; put/get property. So far state-based testing hasn't done much for us.  Let's fix the key generator.  def genKey : Gen[String] = for { c &lt;- Gen.lower s &lt;- Gen.string(Gen.choice1(Gen.lower, Gen.constant('/')), Range.linear(0, 10)) } yield c + s   Leaky File Abstraction​  &gt; Var(Name(15)) = Put(a,b) &gt; Var(Name(16)) = Get(a/) &gt; === Not Equal === &gt; --- lhs --- &gt; None &gt; --- rhs --- &gt; Some(b)   Ahh, now we're getting somewhere a more interesting. We've generated a sequence of putting to a key and then getting the same key with a trailing slash we get back an unexpected value. The key-value abstraction has definitely leaked the underlying file implementation!  This now would have required a slightly more sophisticated property testing rather than a simple round-trip like shown above. We didn't even have to think about it, it just comes with modelling each command once.  Also note that it appears to have found the absolute minimum case, where &quot;a&quot; is the key. If you disable shrinking you may get up to 100 steps, where only two of them are relevant to the failure case.  ","version":"Next","tagName":"h2"},{"title":"Parallel​","type":1,"pageTitle":"State-Based Property Testing Tutorial","url":"/scala-hedgehog/docs/guides-state-tutorial#parallel","content":" Ok, so this is where things get really interesting. By changing two lines we transform our sequential test in to a parallel one. Without changing any of our testing logic!  // Import this somewhere import scala.concurrent.ExecutionContext.Implicits._ def testParallel: Property = { val root = new File(&quot;tmpdir&quot;) val kv = KV.file2(root) parallel( // This is still required, but now means the range of commands for the prefix (see below) Range.linear(1, 10) // This is now required. It specifies the range of command we want to generate for each parallel branch (see below) , Range.linear(1, 10) , State.default , commands(kv) , () =&gt; root.delete() ) }   What does it find?  &gt; --- Prefix --- Var(Name(1)) = Put(a,A) --- Branch 1 --- Var(Name(2)) = Put(a,A) --- Branch 2 --- Var(Name(3)) = Get(a) &gt; === Not Equal === &gt; --- lhs --- &gt; Some(A) &gt; --- rhs --- &gt; Some() &gt; no valid interleaving   This can be slightly harder to read than sequential test output. In parallel tests we start by generating a sequence of actions to be run in a single thread. This is basically to initialise our state/store safely. At this point we then generate two sequences of actions, and execute them on two JVM threads and race them. At this point it's now basically impossible to observe the exact sequence of actions that happened on either thread. Instead what hedgehog does is re-run the model update for each combination of actions, and at least one of the expected results must not be a failure. We must be able to find one (potential) way that we reached the output we observed (ie it mustlinearize)  From that error it looks like we are somehow getting back an empty result from Get That should be impossible, and yet here we are. If we look at the implementation it should be easy to spot:  val w = new FileWriter(f) w.write(v) w.close()   There is a very small window where we open the file writer and write before flushing/closing. And yet hedgehog found it! As a better alternative we could write to a temporary file, and then rename once the data has been written, which should be atomic.  Would we have found that edge-case ourselves with any kind of example or property testing? I highly doubt it!  ","version":"Next","tagName":"h2"},{"title":"Vars​","type":1,"pageTitle":"State-Based Property Testing Tutorial","url":"/scala-hedgehog/docs/guides-state-tutorial#vars","content":" One thing I have left-off is probably the most confusing aspect of the hedgehog implementation of state-based testing (it doesn't exist in ScalaCheck for example). This is that we have to deal with something called Var andEnvironment. These are visible in the execute, update and ensurefunctions:  def execute(env: Environment, i: Input): Either[String, Output] def update(s: State, i: Input, o: Var[Output]): State def ensure(env: Environment, s0: State, s1: State, i: Input, o: Output): Result   For the tests we just wrote we actually don't need them, but they are useful in more complex testing scenarios. Please see the next tutorial to learn more.  For now just ignore them, you can still get started and write some reasonable properties like we just did.  ","version":"Next","tagName":"h3"},{"title":"Resources​","type":1,"pageTitle":"State-Based Property Testing Tutorial","url":"/scala-hedgehog/docs/guides-state-tutorial#resources","content":" The gold standard for an introduction to state-based testing is John Hughes https://www.infoq.com/presentations/testing-techniques-case-study/Don't Write Tests https://teh.id.au/posts/2017/07/15/state-machine-testing/index.htmlhttps://github.com/qfpl/state-machine-testing-courseIntroduction to stateful property based testingState-based Testing Tutorial ","version":"Next","tagName":"h2"},{"title":"Tutorial","type":0,"sectionRef":"#","url":"/scala-hedgehog/docs/guides-tutorial","content":"","keywords":"","version":"Next"},{"title":"Tutorial​","type":1,"pageTitle":"Tutorial","url":"/scala-hedgehog/docs/guides-tutorial#tutorial","content":" TutorialThanksWhat is Hedgehog?Getting started A quick exampleJust a library Properties Results LoggingCombining Generators Case ClassesListsFilteringSized ShrinkingDeterministic resultsClassifications State  ","version":"Next","tagName":"h2"},{"title":"Thanks​","type":1,"pageTitle":"Tutorial","url":"/scala-hedgehog/docs/guides-tutorial#thanks","content":" This guide was originally copied from the very excellentScalaCheck Guideand repurposed for Hedgehog.  ","version":"Next","tagName":"h2"},{"title":"What is Hedgehog?​","type":1,"pageTitle":"Tutorial","url":"/scala-hedgehog/docs/guides-tutorial#what-is-hedgehog","content":" Hedgehog is a tool for testing Scala and Java programs, based on property specifications and automatic test data generation. The basic idea is that you define a property that specifies the behaviour of a method or some unit of code, and Hedgehog checks that the property holds. All test data are generated automatically in a random fashion, so you don't have to worry about any missed cases.  ","version":"Next","tagName":"h2"},{"title":"Getting started​","type":1,"pageTitle":"Tutorial","url":"/scala-hedgehog/docs/guides-tutorial#getting-started","content":" Please follow the general getting startedguide first.  ","version":"Next","tagName":"h2"},{"title":"A quick example​","type":1,"pageTitle":"Tutorial","url":"/scala-hedgehog/docs/guides-tutorial#a-quick-example","content":" import hedgehog._ import hedgehog.runner._ object Spec extends Properties { override def tests: List[Test] = List( property(&quot;property&quot;, propConcatLists) ) def propConcatLists: Property = for { l1 &lt;- Gen.int(Range.linear(-100, 100)).list(Range.linear(0, 100)).forAll l2 &lt;- Gen.int(Range.linear(-100, 100)).list(Range.linear(0, 100)).forAll } yield l1.size + l2.size ==== (l1 ::: l2).size }   You can run this from sbt, either via test or an application with run.  scala&gt; test + Spec$.property: OK, passed 100 tests scala&gt; run Spec + Spec$.property: OK, passed 100 tests   OK, that seemed alright. Now define another property.  def propSqrt: Property = for { n &lt;- Gen.int(Range.linearFrom(0, -100, 100)).forAll } yield scala.math.sqrt(n * n) ==== n   Check it!  - Spec$.property: Falsified after 8 passed tests &gt; -1 &gt; === Not Equal === &gt; --- lhs --- &gt; 1.0 &gt; --- rhs --- &gt; -1.0   Not surprisingly, the property doesn't hold. The argument -1 falsifies it.  ","version":"Next","tagName":"h3"},{"title":"Just a library​","type":1,"pageTitle":"Tutorial","url":"/scala-hedgehog/docs/guides-tutorial#just-a-library","content":" Before we continue it's worth pointing out that for the most past Hedgehog isjust a library. Let's run our first property directly using the API.  scala&gt; import hedgehog._ scala&gt; Property.checkRandom(Spec.propConcatLists).value res0: hedgehog.core.Report = Report(SuccessCount(100),DiscardCount(0),OK)   We can see that the test output is returned as pure data.  Feel free to run the properties in this guide in any way you find most convenient. We will continue to display the results from &quot;running&quot; the property, just because it's more readable.  ","version":"Next","tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"Tutorial","url":"/scala-hedgehog/docs/guides-tutorial#properties","content":" There are two main concepts to Hedgehog are:  ResultsGenerators  Let's start with the more simple and familar results and then move on to the more interesting generators.  ","version":"Next","tagName":"h2"},{"title":"Results​","type":1,"pageTitle":"Tutorial","url":"/scala-hedgehog/docs/guides-tutorial#results","content":" A Result is really a simple Boolean assertion with extra logging. That's it (no really).  def testAdd: Result = Result.assert(1 + 2 == 2 + 1)   You can actually run these from Hedgehog like you would a full property.  object Spec extends Properties { override def tests: List[Test] = List( example(&quot;add&quot;, testAdd) ) def testAdd: Result = Result.assert(1 + 2 == 2 + 1) }   Note that we've used the example test function here instead of property, which is used for the more powerful Property result.  And when we test it, notice that it only runs once and not 100 times.  + Spec$.add: OK, passed 1 tests   This is just like any other test in ScalaTest/specs2/junit/etc.  What happens if we fail though?  def testAdd: Result = Result.assert(1 + 2 == 3 + 4)   Spec$.add: Falsified after 1 passed tests   That's it? What about a useful message telling us what failed? For starters, given that we're just doing an assertion Hedgehog comes with the convenient ==== (quadruple =s) operator:  def testAdd: Result = 1 + 2 ==== 3 + 4   Spec$.testAdd: Falsified after 1 passed tests &gt; === Not Equal === &gt; --- lhs --- &gt; 3 &gt; --- rhs --- &gt; 7   That's a little better. But what happens if we don't just want to check equality?  There is a method called diff which is similar to Result.assert but it gives the similar message to ==== operator's.  diff takes two arguments and the comparison function so that you can do any comparison operation you want on those two arguments.  def testAdd: Result = Result.diff(1 + 2, 3 + 4)(_ == _)   Spec$.testAdd: Falsified after 1 passed tests &gt; === Failed === &gt; --- lhs --- &gt; 3 &gt; --- rhs --- &gt; 7     def a1GtA2: Result = Result.diff(1 + 2, 3 + 4)(_ &gt; _)   Spec$.a1GtA2: Falsified after 0 passed tests &gt; === Failed === &gt; --- lhs --- &gt; 3 &gt; --- rhs --- &gt; 7   If you want to change the log name (i.e. === Failed ===) to something else, you can use diffNamed instead.  e.g.)  Result.diffNamed(&quot;=== Not Equal ===&quot;, 1 + 2, 3 + 4)(_ == _)   Spec$.testAdd: Falsified after 1 passed tests &gt; === Not Equal === &gt; --- lhs --- &gt; 3 &gt; --- rhs --- &gt; 7   In fact, ==== internally uses the diffNamed method.  Logging​  Sometimes it can be difficult to decide exactly what is wrong when a property fails, especially if the property is complex, with many conditions. In such cases, you can log the different parts of the property, so Hedgehog can tell you exactly what part is failing.  From the the example above, what happens if we wanted to check if two numbers were less than each other?  def testTL: Result = Result.assert(2 &lt; 1)   As we saw earlier, this wouldn't give a very useful error message. This is where log comes in handy.  def testTL: Result = Result.assert(2 &lt; 1) .log(&quot;2 is not less than 1&quot;)   We could ever make our own function to help re-use this.  def isLessThan(a: Int, b: Int): Result = Result.assert(a &lt; b) .log(s&quot;$a is not less than $b&quot;) def testTL: Result = isLessThan(2, 1)   Where logging really comes in handy is when you start to usegenerators and the results are different every time.  val complexProp: Property = for { m &lt;- Gen.int(Range.linear(1, 100)).log(&quot;m&quot;) n &lt;- Gen.int(Range.linear(1, 100)).log(&quot;n&quot;) } yield { val res = m + n Result.all(List( Result.assert(res &gt;= m).log(&quot;result &gt; #1&quot;) , Result.assert(res &gt;= n).log(&quot;result &gt; #2&quot;) , Result.assert(res &lt; m + n).log(&quot;result not sum&quot;) )) }   - Spec.property: Falsified after 0 passed tests. &gt; m: 0 &gt; n: 0 &gt; result not sum   The log operator can also be used to inspect intermediate values used in the properties, which can be very useful when trying to understand why a property fails. Hedgehog always presents the generated property arguments but sometimes you need to quickly see the value of an intermediate calculation. See the following example, which tries to specify multiplication in a somewhat naive way:  def propMul: Property = for { n &lt;- Gen.int(Range.linear(1, 100)).log(&quot;n&quot;) m &lt;- Gen.int(Range.linear(1, 100)).log(&quot;m&quot;) } yield { val res = n*m Result.all(List( (res / m ==== n).log(&quot;div1&quot;) , (res / n ==== m).log(&quot;div2&quot;) , Result.assert(res &gt; m).log(&quot;lt1&quot;) , Result.assert(res &gt; n).log(&quot;lt2&quot;) )).log(&quot;evidence = &quot; + res) }   Here we have four different conditions, each with its own label. A fifth label is added to the combined property to record the result of the multiplication. When we check the property, Hedgehog tells us the following:  - Spec$.example: Falsified after 0 passed tests. &gt; n: 1 &gt; n: 1 &gt; lt1 &gt; lt2 &gt; evidence = 1   As you can see, you can add as many logs as you want to your result, Hedgehog will only present the failing ones for the smallest example.  Combining​  Results can be combined with other results into new ones using familiar boolean logic.  def p1: Result = &quot;a&quot; ==== &quot;a&quot; def p2: Result = 1 ==== 1 def p3: Result = p1 and p2 def p4: Result = p1 or p2 // same as p1 and p2 def p5: Result = Result.all(List(p1, p2)) // same as p1 or p2 def p6: Result = Result.any(List(p1, p2))   Here, p3 will hold if and only if both p1 and p2 hold, p4 will hold if either p1 or p2 holds.  ","version":"Next","tagName":"h3"},{"title":"Generators​","type":1,"pageTitle":"Tutorial","url":"/scala-hedgehog/docs/guides-tutorial#generators","content":" Generators are responsible for generating test data in Hedgehog, and are represented by the hedgehog.Gen class. You need to know how to use this class if you want Hedgehog to generate data of types that are not supported by default to state properties about a specific subset of a type. In the Genobject, there are several methods for creating new and modifying existing generators. We will show how to use some of them in this section. For a more complete reference of what is available, please see the Github source.  A generator can be seen simply as a function that takes some generation parameters, and (maybe) returns a generated value. That is, the type Gen[T]may be thought of as a function of type Seed =&gt; Option[T]. However, theGen class contains additional methods to make it possible to map generators, use them in for-comprehensions and so on. Conceptually, though, you should think of generators simply as functions, and the combinators in the Genobject can be used to create or modify the behaviour of such generator functions.  Let's see how to create a new generator. The best way to do it is to use the generator combinators that exist in the hedgehoge.Gen module. These can be combined using a for-comprehension. Suppose you need a generator which generates a tuple that contains two random integer values, one of them being at least twice as big as the other. The following definition does this:  val myGen: Gen[(Int, Int)] = for { n &lt;- Gen.int(Range.linear(10, 20)) m &lt;- Gen.int(Range.linear(2*n, 500)) } yield (n, m)   You can create generators that picks one value out of a selection of values. The following generator generates a vowel:  def vowel: Gen[Char] = Gen.element1('A', 'E', 'I', 'O', 'U', 'Y')   The element1 method creates a generator that randomly picks one of its parameters each time it generates a value. Notice that plain values are implicitly converted to generators (which always generates that value) if needed.  The distribution is uniform, but if you want to control it you can use thefrequency1 combinator:  def vowel: Gen[Char] = Gen.frequency1( (3, 'A') , (4, 'E') , (2, 'I') , (3, 'O') , (1, 'U') , (1, 'Y') )   Now, the vowel generator will generate Es more often than Ys. Roughly, 4/14 of the values generated will be Es, and 1/14 of them will be Ys.  Case Classes​  It is very simple to generate random instances of case classes in Hedgehog. Consider the following example where a binary integer tree is generated:  sealed abstract class Tree case class Node(left: Tree, right: Tree, v: Int) extends Tree case object Leaf extends Tree val genLeaf: Gen[Tree] = Gen.constant(Leaf) def genNode: Gen[Tree] = for { v &lt;- Gen.int(Range.linear(-100, 100)) left &lt;- genTree right &lt;- genTree } yield Node(left, right, v) def genTree: Gen[Tree] = Gen.choice1(genLeaf, genNode)   We can now generate a sample tree:  def testTree: Property = forAll { t &lt;- genTree.forAll } yield { println(t) Result.success }   Leaf Node(Leaf,Leaf,-71) Node(Node(Leaf,Leaf,-71),Node(Leaf,Leaf,-49),17),Leaf,-20 Node(Node(Node(Node(Node(Leaf,Leaf,-71),Node(Leaf,Leaf,-49),17),Leaf,-20),Leaf,-7),Node(Node(Leaf,Leaf,26),Leaf,-3),49) Node(Leaf,Node(Node(Node(Node(Node(Node(Leaf,Leaf,-71),Node(Leaf,Leaf,-49),17),Leaf,-20),Leaf,-7),Node(Node(Leaf,Leaf,26),Leaf,-3),49),Leaf,84),-29)   Lists​  There is a use generator, list, that generates a list of the current Gen. You can use it in the following way:  def genIntList: Gen[List[Int]] = Gen.element1(1, 3, 5).list(Range.linear(0, 10)) def genBoolList: Gen[List[Boolean]] = Gen.constant(true).list(Range.linear(0, 10)) def genCharList: Gen[List[Char]] = Gen.alpha.list(Range.linear(0, 10))   It might be annoying to deal with a list of characters, which is where theGen.string function comes in handy.  def genStringList: Gen[String] = Gen.string(Gen.alpha, Range.linear(0, 10))   Filtering​  Generator values can be restricted to ensure they meet some precondition.  val propMakeList: Property = for { n &lt;- Gen.int(Range.linear(0, 100)) .ensure(n =&gt; n % 2 == 0) .forAll } yield List.fill(n)(&quot;&quot;).length ==== n }   Now Hedgehog will only care for the cases when n is even.  If ensure is given a condition that is hard or impossible to fulfill, Hedgehog might not find enough passing test cases to state that the property holds. In the following trivial example, all cases where n is non-zero will be thrown away:  def propTrivial: Property = for { n &lt;- Gen.int(Range.linear(0, 100)) .ensure(n =&gt; n == 0) .forAll } yield n ==== 0   &gt; Gave up after only 55 passed tests. 100 were discarded   It is possible to tell Hedgehog to try harder when it generates test cases, but generally you should try to refactor your property specification instead of generating more test cases, if you get this scenario.  Using ensure, we realise that a property might not just pass or fail, it could also be undecided if the implication condition doesn't get fulfilled.  Sized​  When Hedgehog uses a generator to generate a value, it feeds it with some parameters. One of the parameters the generator is given, is a Size value, which some generators use to generate their values. If you want to use the size parameter in your own generator, you can use the Gen.sized method:  def matrix[T](g: Gen[T]): Gen[List[List[T]]] = Gen.sized(size =&gt; { val side = scala.math.sqrt(size.value).toInt g.list(Range.linear(0, side)).list(Range.linear(0, side)) })   The matrix generator will use a given generator and create a matrix which side is based on the generator size parameter. It uses the list function which creates a sequence of given length filled with values obtained from the given generator.  ","version":"Next","tagName":"h3"},{"title":"Shrinking​","type":1,"pageTitle":"Tutorial","url":"/scala-hedgehog/docs/guides-tutorial#shrinking","content":" In some ways the most interesting and important feature of Hedgehog is that if it finds an argument that falsifies a property, it tries to shrink that argument before it is reported.  This is done automatically! This is crucially different from [QuickCheck] and [ScalaCheck] which requires some hand-holding when it comes to shrinking. We recommended watching the original presentationfor more information on how this works.  Let's look at specifying a property that says that no list has duplicate elements in it. This is of course not true, but we want to see the test case shrinking in action!  def p1: Property = for { l &lt;- Gen.int(Range.linearFrom(0, -100, 100)).list(Range.linear(0, 100)).log(&quot;l&quot;) } yield l ==== l.distinct   Now, run the tests:  - Spec$.example: Falsified after 5 passed tests &gt; l: List(0,0) &gt; === Not Equal === &gt; --- lhs --- &gt; List(0,0) &gt; --- rhs --- &gt; List(0)   Notice in particular the i: List(0, 0), which captures the smallest possible value that doesn't satisfy the invalid property.  Let's try that again, but let's see what else it tried.  def p1: Property = for { l &lt;- Gen.int(Range.linearFrom(0, -100, 100)).list(Range.linear(0, 100)).log(&quot;i&quot;) } yield { println(l) l ==== l.distinct }   List() List(1, -2) List(-2, -3) List(1, 4, 1) List(0, 4, 1) List(1, 0, 1) List(1, 0, 0) List() List(0, 0) List() List(0)   You can see after a few tries Hedgehog finds an invalid example List(1, 4, 1), and starts to shrink both the values down to 0 and also the list size.  ","version":"Next","tagName":"h3"},{"title":"Deterministic results​","type":1,"pageTitle":"Tutorial","url":"/scala-hedgehog/docs/guides-tutorial#deterministic-results","content":" By default, Hedgehog uses a random seed that is based on the current system time. Normally, this is exactly what you want. However, if you have a failing test, the randomness of the generated test data can make it very difficult to reproduce and analyse the problem — especially if the test is only failing sporadically. In this situation, it would be better if you could get exactly the same generated test data that caused the test to fail.  This is why Hedgehog logs the seed together with the test results. In your console, you should see something like this:  Using random seed: 58973622580784 + hedgehog.PropertyTest$.example1: OK, passed 1 tests + hedgehog.PropertyTest$.applicative: OK, passed 1 tests + hedgehog.PropertyTest$.applicative shrink: OK, passed 100 tests   Now imagine of these tests fails sporadically in your build pipeline. To analyse the problem locally, you can reproduce this test run by setting the seed to the same value. All you need to do is set the environment variable HEDGEHOG_SEED to the value in question.  Example:  export HEDGEHOG_SEED=58973622580784   Now you can reproduce the test run you're interested in. Hedgehog will inform you that it used the seed from the environment variable:  Using seed from environment variable HEDGEHOG_SEED: 58973622580784 + hedgehog.PropertyTest$.example1: OK, passed 1 tests + hedgehog.PropertyTest$.applicative: OK, passed 1 tests + hedgehog.PropertyTest$.applicative shrink: OK, passed 100 tests   ","version":"Next","tagName":"h3"},{"title":"Classifications​","type":1,"pageTitle":"Tutorial","url":"/scala-hedgehog/docs/guides-tutorial#classifications","content":" Using classify you can add classifications to your generator's data, for example:   def testReverse: Property = for { xs &lt;- Gen.alpha.list(Range.linear(0, 10)).forAll .classify(&quot;empty&quot;, _.isEmpty) .classify(&quot;nonempty&quot;, _.nonEmpty) } yield xs.reverse.reverse ==== xs   Running that property will produce a result like:  [info] + hedgehog.examples.ReverseTest.reverse: OK, passed 100 tests [info] &gt; 69% nonempty List(a) [info] &gt; 31% empty List()   Notice how, in addition to the percentage, it also presents a shrunk example for that classifier.  Using cover you may also specify a minimum coverage percentage for the given classification:   def testReverse: Property = for { xs &lt;- Gen.alpha.list(Range.linear(0, 10)).forAll .cover(50, &quot;empty&quot;, _.isEmpty) .cover(50, &quot;nonempty&quot;, _.nonEmpty) } yield xs.reverse.reverse ==== xs   [info] - hedgehog.examples.ReverseTest.reverse: Falsified after 100 passed tests [info] &gt; Insufficient coverage. [info] &gt; 93% nonempty 50% ✓ List(a) [info] &gt; 7% empty 50% ✗ List()   Finally:  label(name) is an alias for classify(name, _ =&gt; true), andcollect is an alias for labal using the value's toString as the classification (label name)  ","version":"Next","tagName":"h3"},{"title":"State​","type":1,"pageTitle":"Tutorial","url":"/scala-hedgehog/docs/guides-tutorial#state","content":" For a separate tutorial on state-based property testing please continuehere. ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}