"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[886],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return m}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=d(a),m=r,h=c["".concat(s,".").concat(m)]||c[m]||u[m]||i;return a?n.createElement(h,o(o({ref:t},p),{},{components:a})):n.createElement(h,o({ref:t},p))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var d=2;d<i;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},6944:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return p},default:function(){return c}});var n=a(7462),r=a(3366),i=(a(7294),a(3905)),o=["components"],l={title:"State-Based Property Testing Tutorial (Part 2 - Vars)",sidebar_label:"State-Based Testing (2)",slug:"/guides-state-tutorial-vars"},s=void 0,d={unversionedId:"guides/state-tutorial-vars",id:"guides/state-tutorial-vars",isDocsHomePage:!1,title:"State-Based Property Testing Tutorial (Part 2 - Vars)",description:"State-Based Property Testing Tutorial (Part 2 - Vars)",source:"@site/../generated-docs/target/mdoc/guides/state-tutorial-vars.md",sourceDirName:"guides",slug:"/guides-state-tutorial-vars",permalink:"/scala-hedgehog/docs/guides-state-tutorial-vars",tags:[],version:"current",frontMatter:{title:"State-Based Property Testing Tutorial (Part 2 - Vars)",sidebar_label:"State-Based Testing (2)",slug:"/guides-state-tutorial-vars"},sidebar:"docs",previous:{title:"State-Based Testing (1)",permalink:"/scala-hedgehog/docs/guides-state-tutorial"},next:{title:"Migration From ScalaCheck",permalink:"/scala-hedgehog/docs/guides-migration-from-scalacheck"}},p=[{value:"State-Based Property Testing Tutorial (Part 2 - Vars)",id:"state-based-property-testing-tutorial-part-2---vars",children:[]},{value:"Follow Along",id:"follow-along",children:[]},{value:"The Problem",id:"the-problem",children:[{value:"Model (take 1)",id:"model-take-1",children:[]},{value:"Gen",id:"gen",children:[]},{value:"Execute (take 1)",id:"execute-take-1",children:[]},{value:"Update",id:"update",children:[]},{value:"WTF",id:"wtf",children:[]},{value:"Model (take 2)",id:"model-take-2",children:[]},{value:"Execute (take 2)",id:"execute-take-2",children:[]},{value:"Ensure",id:"ensure",children:[]}]},{value:"Debugging",id:"debugging",children:[]},{value:"Resources",id:"resources",children:[]}],u={toc:p};function c(e){var t=e.components,a=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"state-based-property-testing-tutorial-part-2---vars"},"State-Based Property Testing Tutorial (Part 2 - Vars)"),(0,i.kt)("p",null,"This tutorial continues on from the ",(0,i.kt)("a",{parentName:"p",href:"/scala-hedgehog/docs/guides-state-tutorial"},"first tutorial"),"."),(0,i.kt)("h2",{id:"follow-along"},"Follow Along"),(0,i.kt)("p",null,"Please feel to play along and tinker with the code."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$ ./sbt\n> example/runMain hedgehog.examples.state.CRTest\n")),(0,i.kt)("h2",{id:"the-problem"},"The Problem"),(0,i.kt)("p",null,"To start with let's define an interface/abstraction for something we want to\ntest against, part of a basic create/read/update/delete or ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Create,_read,_update_and_delete"},"CRUD")," store, which\nI'm calling ",(0,i.kt)("inlineCode",{parentName:"p"},"CR")," as we only support create/read to simplify the example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait CR {\n\n  def create(v: String): CRId\n\n  def read(id: CRId): Option[String]\n}\n\ncase class CRId(render: String)\n")),(0,i.kt)("p",null,"NOTE: The big difference here from the previous ",(0,i.kt)("inlineCode",{parentName:"p"},"KV")," is that the service is\nreturning it's own identifier instead of being passed on. That has implications\nfor testing the state with Hedgehog, which require something extra..."),(0,i.kt)("h3",{id:"model-take-1"},"Model (take 1)"),(0,i.kt)("p",null,"Similar to our previous example, this also seems fairly straight forward.\nBut we're about to hit a snag..."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class State(map: Map[CRId, String])\n")),(0,i.kt)("p",null,"And our command input types:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Create(value: String)\ncase class Read(id: CRId)\n")),(0,i.kt)("p",null,"Now let's step throught the ",(0,i.kt)("inlineCode",{parentName:"p"},"Command")," functions for ",(0,i.kt)("inlineCode",{parentName:"p"},"create"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"read")," like\nbefore:"),(0,i.kt)("h3",{id:"gen"},"Gen"),(0,i.kt)("p",null,"Generation is fairly typical. Note that we can't really usefully create a\n",(0,i.kt)("inlineCode",{parentName:"p"},"Read")," value until we have at least one value in ",(0,i.kt)("inlineCode",{parentName:"p"},"State"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def gen(s: State): Option[Gen[Create]] =\n  Some(for {\n    v <- Gen.string(Gen.ascii, Range.linear(1, 10))\n  } yield Create(v))\n\ndef gen(s: State): Option[Gen[Read]] =\n  s.map.keys.toList match {\n    case Nil =>\n      // We haven't created anything yet\n      None\n    case h :: t =>\n      Some(Gen.element(h, t).map(Read(_)))\n  }\n")),(0,i.kt)("h3",{id:"execute-take-1"},"Execute (take 1)"),(0,i.kt)("p",null,"So far everything lines up just like before:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def execute(i: Create): Either[String, CRId] =\n  Right(cr.create(i.key, i.value))\n\ndef execute(i: Read): Either[String, Option[String]] =\n  Right(cr.read(i.key))\n")),(0,i.kt)("h3",{id:"update"},"Update"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def update(s: State, i: Create, o: Var[CRId]): State =\n  s.copy(map = s.map + (o -> i.value))\n\n// There are no side-effects for get, so nothing to do\ndef update(s: State, i: Read): State =\n  s\n")),(0,i.kt)("p",null,"Hang on, what's that ",(0,i.kt)("inlineCode",{parentName:"p"},"Var[CRid]")," doing?!? Why isn't it just a concrete ",(0,i.kt)("inlineCode",{parentName:"p"},"CRId"),"?\nThat code doesn't even compile!"),(0,i.kt)("h3",{id:"wtf"},"WTF"),(0,i.kt)("p",null,'It turns out that Hedgehog forces a very clear separation for functions that\ncan access the "real world" state, and those that can\'t. The reasons for this\nare a little involved, but the basic idea is that we can generate a full\nsequence of commands up-front, without having called ',(0,i.kt)("inlineCode",{parentName:"p"},"execute"),'. So the\nquestion/problem then becomes, how do we capture the "result" to be used in\n',(0,i.kt)("inlineCode",{parentName:"p"},"gen"),", like we ",(0,i.kt)("em",{parentName:"p"},"need")," to do for ",(0,i.kt)("inlineCode",{parentName:"p"},"read"),"?"),(0,i.kt)("p",null,"This is where ",(0,i.kt)("inlineCode",{parentName:"p"},"Var")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," come in. For each ",(0,i.kt)("inlineCode",{parentName:"p"},"Command.execute"),",\nHedgehog allocates a unique ",(0,i.kt)("inlineCode",{parentName:"p"},"Name")," (just a plain old incrementing ",(0,i.kt)("inlineCode",{parentName:"p"},"Int"),"), and\npassed ",(0,i.kt)("em",{parentName:"p"},"that"),' to the "pure" functions, like ',(0,i.kt)("inlineCode",{parentName:"p"},"update")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"gen"),". It's only when\nwe need the ",(0,i.kt)("em",{parentName:"p"},"concrete")," values do we get access to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," to look\nthem up."),(0,i.kt)("p",null,"Here is the relevant data types, that should hopefully make more sense now?"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Name(value: Int)\n\ncase class Environment(map: Map[Name, Any])\n\ncase class Var[A](name: Name) {\n  def get(env: Env): A =\n    env.map(name)\n}\n")),(0,i.kt)("h3",{id:"model-take-2"},"Model (take 2)"),(0,i.kt)("p",null,"So we will need to tweak our model and input slightly to use ",(0,i.kt)("inlineCode",{parentName:"p"},"Var"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class State(map: Map[Var[CRId], String])\n\ncase class Read(id: Var[CRId])\n")),(0,i.kt)("h3",{id:"execute-take-2"},"Execute (take 2)"),(0,i.kt)("p",null,"So let's try that again. Note that we now use ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Read"),"\nversion to ",(0,i.kt)("inlineCode",{parentName:"p"},"get")," the concrete ",(0,i.kt)("inlineCode",{parentName:"p"},"CRId")," returned from ",(0,i.kt)("inlineCode",{parentName:"p"},"create"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def execute(env: Environment, i: Create): Either[String, CRId] =\n  Right(cr.create(i.key, i.value))\n\ndef execute(env: Environment, i: Read): Either[String, Option[String]] =\n  Right(cr.read(i.key.get(env)))\n")),(0,i.kt)("h3",{id:"ensure"},"Ensure"),(0,i.kt)("p",null,"This is identical to ",(0,i.kt)("inlineCode",{parentName:"p"},"KV"),", although notice we ",(0,i.kt)("em",{parentName:"p"},"could")," use ",(0,i.kt)("inlineCode",{parentName:"p"},"Environment")," here if\nwe needed to, unlike ",(0,i.kt)("inlineCode",{parentName:"p"},"update"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// Almost the reverse of update, for side-effect operations we may not observe anything just yet\ndef ensure(env: Environment, s0: State, s1: State, i: Create, o: CRId): Result =\n  Result.success\n\ndef ensure(env: Environment, s0: State, s1: State, i: Read, o: Option[String]): Result =\n  s1.map.get(i.key) ==== o\n")),(0,i.kt)("h2",{id:"debugging"},"Debugging"),(0,i.kt)("p",null,"Let's look at the output of a failed test again:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"Var(Name(0)) = Create(a)\nVar(Name(1)) = Create(b)\nVar(Name(2)) = Read(Var(Name(0)))\n")),(0,i.kt)("p",null,"We can start to see that each command is shown to be assigning the result to a\nnew, unique ",(0,i.kt)("inlineCode",{parentName:"p"},"Var"),". We aren't looking at the ",(0,i.kt)("em",{parentName:"p"},"actual")," ",(0,i.kt)("inlineCode",{parentName:"p"},"CRId")," values.  Hedgehog\n(currently) can't tell that ",(0,i.kt)("inlineCode",{parentName:"p"},"Read")," doesn't actually return anything (useful)\nand so the ",(0,i.kt)("inlineCode",{parentName:"p"},"Unit")," value is also asigned to a new ",(0,i.kt)("inlineCode",{parentName:"p"},"Var"),"."),(0,i.kt)("h2",{id:"resources"},"Resources"),(0,i.kt)("p",null,"Unfortunately there isn't much documentation for this approach at the moment."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"http://www.cse.chalmers.se/~nicsma/papers/finding-race-conditions.pdf"},"Finding Race Conditions in Erlang with QuickCheck and PULSE"),"\nHedgehog follows a vague description of this implementation which is mentioned\nin this paper."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://teh.id.au/posts/2017/07/15/state-machine-testing/index.html#parameterised-actions"},"State machine testing with Hedgehog")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/scala-hedgehog/docs/guides-haskell-differences#state-vars"},"Haskell Differences"))))}c.isMDXComponent=!0}}]);