"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[914],{8371:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>h});var a=n(4848),s=n(8453);const i={title:"State-Based Property Testing Tutorial",sidebar_position:2,sidebar_label:"State-Based Testing (1)",slug:"/guides-state-tutorial"},r=void 0,o={id:"guides/state-tutorial",title:"State-Based Property Testing Tutorial",description:"State-Based Property Testing Tutorial",source:"@site/../generated-docs/target/mdoc/guides/state-tutorial.md",sourceDirName:"guides",slug:"/guides-state-tutorial",permalink:"/scala-hedgehog/docs/guides-state-tutorial",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"State-Based Property Testing Tutorial",sidebar_position:2,sidebar_label:"State-Based Testing (1)",slug:"/guides-state-tutorial"},sidebar:"tutorialSidebar",previous:{title:"Tutorial",permalink:"/scala-hedgehog/docs/guides-tutorial"},next:{title:"State-Based Testing (2)",permalink:"/scala-hedgehog/docs/guides-state-tutorial-vars"}},l={},h=[{value:"State-Based Property Testing Tutorial",id:"state-based-property-testing-tutorial",level:2},{value:"Follow Along",id:"follow-along",level:2},{value:"The Problem",id:"the-problem",level:2},{value:"Model",id:"model",level:2},{value:"Gen",id:"gen",level:3},{value:"Execute",id:"execute",level:3},{value:"Update",id:"update",level:3},{value:"Ensure",id:"ensure",level:3},{value:"FAQ",id:"faq",level:2},{value:"Sequential",id:"sequential",level:2},{value:"Invalid file path",id:"invalid-file-path",level:4},{value:"Leaky File Abstraction",id:"leaky-file-abstraction",level:4},{value:"Parallel",id:"parallel",level:2},{value:"Vars",id:"vars",level:3},{value:"Resources",id:"resources",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"state-based-property-testing-tutorial",children:"State-Based Property Testing Tutorial"}),"\n",(0,a.jsx)(t.h2,{id:"follow-along",children:"Follow Along"}),"\n",(0,a.jsx)(t.p,{children:"Please feel to play along and tinker with the code."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"$ ./sbt\n> example/runMain hedgehog.examples.state.KVTest\n"})}),"\n",(0,a.jsx)(t.h2,{id:"the-problem",children:"The Problem"}),"\n",(0,a.jsx)(t.p,{children:"To start with let's define an interface/abstraction for something we want to\ntest against, the most basic key/value store:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"trait KV {\n\n  def put(k: String, v: String): Unit\n\n  def get(k: String): Option[String]\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"Now let's write some normal property tests to test it:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"def testPut(kv: KV): Property =\n  for {\n    k <- genKey\n    v <- genValue\n  } yield {\n    kv.put(k, v)\n    kv.get(k) ==== Some(v)\n  }\n\ndef testGetMissing(kv: KV): Property =\n  for {\n    v <- genValue\n  } yield {\n    kv.get(k) ==== None\n  }\n"})}),"\n",(0,a.jsx)(t.p,{children:"So far so good. But do we think we have tested all the cases? Think about that\nfor a second and let's see what happens..."}),"\n",(0,a.jsxs)(t.p,{children:["We're looking at an interface with just two functions, but there are infinite\nways in which we can interact with them. How well do are tests scale when we add\n",(0,a.jsx)(t.em,{children:"one"})," more function (ie delete)? Or ten?"]}),"\n",(0,a.jsx)(t.p,{children:"What we really want to do is let our property testing library generate the\ninteractions themselves!"}),"\n",(0,a.jsx)(t.h2,{id:"model",children:"Model"}),"\n",(0,a.jsx)(t.p,{children:'At a conceptual level the idea with state-based testing is to "model" the real\nworld with something pure (ie in memory). We then execute real commands against\nour system/api, and compare the result with what our model expects.'}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:"https://res.infoq.com/presentations/testing-techniques-case-study/en/slides/sl6.jpg",alt:""})}),"\n",(0,a.jsx)(t.p,{children:'At the technical level the current approach to writing a state-based test is to\nimplement a series of very specific functions for each operation or "command"\nyou want to test.'}),"\n",(0,a.jsxs)(t.p,{children:["Firstly let's create our ",(0,a.jsx)(t.em,{children:"pure"})," domain model for testing. In this case it's\ntrivial to think of a key-value store as an immutable ",(0,a.jsx)(t.code,{children:"Map"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"case class State(map: Map[String, String])\n"})}),"\n",(0,a.jsx)(t.p,{children:"For each command you quite often end up just reifying the function arguments in\nto a data type:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"case class Put(key: String, value: String)\ncase class Get(key: String)\n"})}),"\n",(0,a.jsxs)(t.p,{children:["For each command you need to implement the ",(0,a.jsx)(t.a,{href:"https://github.com/hedgehogqa/scala-hedgehog/blob/master/core/shared/src/main/scala/hedgehog/state/Command.scala",children:"Command"})," interface. This can look\nquite daunting so let's step through it:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"def command(kv: KV): CommandIO[State] =\n\n  new Command[State, Input, Output] {\n\n    def gen(s: State): Option[Gen[Input]]\n\n    def execute(i: Input): Either[String, Output]\n\n    def update(s: State, i: Input): State\n\n    def ensure(s0: State, s1: State, i: Input, o: Output): Result\n  }\n"})}),"\n",(0,a.jsx)(t.h3,{id:"gen",children:"Gen"}),"\n",(0,a.jsx)(t.p,{children:"Firstly, we need to be able to generate random inputs to our command."}),"\n",(0,a.jsx)(t.p,{children:"The key thing to note is that we take in the current state, which we might want\nto use to generate some values.  There might be cases where no valid input can\nbe generated. For example you need to call put before you can call get.  One\nsimple way to generate our operations would be something like:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"def gen(s: State): Option[Gen[Put]] =\n  Some(for {\n    k <- Gen.string(Gen.ascii, Range.linear(1, 10))\n    v <- Gen.string(Gen.ascii, Range.linear(1, 10))\n  } yield Put(k, v))\n\ndef gen(s: State): Option[Gen[Get]] =\n  Some(Gen.string(Gen.ascii, Range.linear(1, 10))\n    .map(Get(_)))\n"})}),"\n",(0,a.jsx)(t.p,{children:"But how often do we generate the same keys in either case? Shouldn't we try to\ngenerate similar keys sometimes?"}),"\n",(0,a.jsx)(t.p,{children:"A slightly better attempt:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"def genKey: Gen[String] =\n  Gen.string(Gen.ascii, Range.linear(1, 10))\n\ndef gen(s: State): Option[Gen[Put]] =\n  Some(for {\n    k <- s.map.keys.toList match {\n      case Nil =>\n        genKey\n      case h :: t =>\n        // Choice between known and unknown keys\n        Gen.frequency1(\n          50 -> genKey\n        , 50 -> Gen.element(h, t)\n        )\n    }\n    // Always generate a unique value\n    v <- Gen.string(Gen.ascii, Range.linear(1, 10))\n  } yield Put(k, v))\n\ndef gen(s: State): Option[Gen[Get]] =\n  Some((s.map.keys.toList match {\n    case Nil =>\n      genKey\n    case h :: t =>\n      // Mostly get values we know to exist, but also try values that don't\n      Gen.frequency1(\n        80 -> Gen.element(h, t)\n      , 20 -> genKey\n      )\n  }).map(Get(_)))\n"})}),"\n",(0,a.jsxs)(t.p,{children:["That's definitely a little more involved, but you can see we're getting a good\nspread of put/get values with known/duplicate and unknown keys. That should\ncover everything, which is a critical component of ",(0,a.jsx)(t.em,{children:"good"})," property testing in\ngeneral."]}),"\n",(0,a.jsx)(t.h3,{id:"execute",children:"Execute"}),"\n",(0,a.jsx)(t.p,{children:'This is the easy bit, just call our operation. Note the lack of our model/state,\nyou can also interact with the "real world".'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"def execute(i: Put): Either[String, Unit] =\n  Right(kv.put(i.key, i.value))\n\ndef execute(i: Get): Either[String, Option[String]] =\n  Right(kv.get(i.key))\n"})}),"\n",(0,a.jsx)(t.h3,{id:"update",children:"Update"}),"\n",(0,a.jsx)(t.p,{children:'This is where we need to "model" what we expect that operation to do in our pure state.'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"def update(s: State, i: Put): State =\n  s.copy(map = s.map + (i.key -> i.value))\n\n// There are no side-effects for get, so nothing to do\ndef update(s: State, i: Get): State =\n  s\n"})}),"\n",(0,a.jsx)(t.h3,{id:"ensure",children:"Ensure"}),"\n",(0,a.jsx)(t.p,{children:'This is the "post condition". What did we expect to happen in the real world vs\nour model?'}),"\n",(0,a.jsxs)(t.p,{children:["Just as a side note, the ",(0,a.jsx)(t.code,{children:"s0"})," means the state before update is run, and ",(0,a.jsx)(t.code,{children:"s1"})," is\nthe current state. It's always possible, and fairly common, to just use ",(0,a.jsx)(t.code,{children:"s1"})," and\nthe input value."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"// Almost the reverse of update, for side-effect operations we may not observe anything just yet\ndef ensure(s0: State, s1: State, i: Put, o: Unit): Result =\n  Result.success\n\ndef ensure(s0: State, s1: State, i: Get, o: Option[String]): Result =\n  s1.map.get(i.key) ==== o\n"})}),"\n",(0,a.jsx)(t.h2,{id:"faq",children:"FAQ"}),"\n",(0,a.jsx)(t.p,{children:"The common question here is \"won't we just end up with two implementations\"? Yes\nand no. Obviously this is a trivial example. The model is so simple that we can\nactually have a 100% full re-implementation. This won't always be the case, we\nmay only want to guarantee some invariants are true, but not the exact\nbehaviour. Also remember that we haven't actually looked at the implementation\nof KV yet. It might be storing keys on files, or across the network with\nmultiple copies. If there are any bugs in any of that code it's quite likely we\nwill find it at some point."}),"\n",(0,a.jsx)(t.h2,{id:"sequential",children:"Sequential"}),"\n",(0,a.jsx)(t.p,{children:"So the final piece is to hook up all our commands to form a property. It would look something like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:'def testKVFileSequential: Property = {\n  val root = File("tmpdir")\n  // Create a simple file-system KV store\n  val kv = KV.file(root)\n  sequential(\n    // The range of commands to generate\n      Range.linear(1, 100)\n    // Out initial state to be used for each test run\n    , State(Map())\n    // The list of commands\n    , List(putCommand, getCommand)\n    // Any cleanup code for the real-world, which in this case is to delete the KV file root for each test run\n    , () => root.delete()\n    )\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"This can be added to Hedgehog like any other property:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:'override def tests: List[Test] =\n  List(\n    property("test file KV (sequential)", testKVFileSequential)\n  )\n'})}),"\n",(0,a.jsx)(t.p,{children:"Some errors that a naive  file implementation found:"}),"\n",(0,a.jsx)(t.h4,{id:"invalid-file-path",children:"Invalid file path"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"> Var(Name(0)) = Put(???,b)\n\n> Error thrown running execute: Invalid file path\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The first set of line(s) are the series of commands that have been run in order\n(ignore ",(0,a.jsx)(t.code,{children:"Var"})," for now). Everything after that is our ",(0,a.jsx)(t.code,{children:"Result"})," log."]}),"\n",(0,a.jsx)(t.p,{children:"So I'm generating invalid keys. So there is some restrictions on what our keys\ncan be. Interesting. For now update the generator to something much more\nrestrictive."}),"\n",(0,a.jsx)(t.p,{children:'Note that this would have been found pretty quickly by our "normal" put/get\nproperty. So far state-based testing hasn\'t done much for us.'}),"\n",(0,a.jsx)(t.p,{children:"Let's fix the key generator."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"def genKey : Gen[String] =\n  for {\n    c <- Gen.lower\n    s <- Gen.string(Gen.choice1(Gen.lower, Gen.constant('/')), Range.linear(0, 10))\n  } yield c + s\n"})}),"\n",(0,a.jsx)(t.h4,{id:"leaky-file-abstraction",children:"Leaky File Abstraction"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"> Var(Name(15)) = Put(a,b)\n> Var(Name(16)) = Get(a/)\n\n> === Not Equal ===\n> --- lhs ---\n> None\n> --- rhs ---\n> Some(b)\n"})}),"\n",(0,a.jsx)(t.p,{children:"Ahh, now we're getting somewhere a more interesting. We've generated a sequence\nof putting to a key and then getting the same key with a trailing slash we get\nback an unexpected value. The key-value abstraction has definitely leaked the\nunderlying file implementation!"}),"\n",(0,a.jsx)(t.p,{children:"This now would have required a slightly more sophisticated property testing\nrather than a simple round-trip like shown above. We didn't even have to think\nabout it, it just comes with modelling each command once."}),"\n",(0,a.jsx)(t.p,{children:'Also note that it appears to have found the absolute minimum case, where "a" is\nthe key. If you disable shrinking you may get up to 100 steps, where only two of\nthem are relevant to the failure case.'}),"\n",(0,a.jsx)(t.h2,{id:"parallel",children:"Parallel"}),"\n",(0,a.jsx)(t.p,{children:"Ok, so this is where things get really interesting. By changing two lines we\ntransform our sequential test in to a parallel one. Without changing any of our\ntesting logic!"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:'// Import this somewhere\nimport scala.concurrent.ExecutionContext.Implicits._\n\ndef testParallel: Property = {\n  val root = new File("tmpdir")\n  val kv = KV.file2(root)\n  parallel(\n    // This is still required, but now means the range of commands for the prefix (see below)\n      Range.linear(1, 10)\n    // This is now required. It specifies the range of command we want to generate for each parallel branch (see below)\n    , Range.linear(1, 10)\n    , State.default\n    , commands(kv)\n    , () => root.delete()\n    )\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"What does it find?"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"> --- Prefix ---\nVar(Name(1)) = Put(a,A)\n--- Branch 1 ---\nVar(Name(2)) = Put(a,A)\n--- Branch 2 ---\nVar(Name(3)) = Get(a)\n\n> === Not Equal ===\n> --- lhs ---\n> Some(A)\n> --- rhs ---\n> Some()\n\n> no valid interleaving\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This can be slightly harder to read than sequential test output. In parallel\ntests we start by generating a sequence of actions to be run in a single thread.\nThis is basically to initialise our state/store safely. At this point we then\ngenerate two sequences of actions, and execute them on two JVM threads and race\nthem. At this point it's now basically impossible to observe the exact sequence\nof actions that happened on either thread. Instead what hedgehog does is re-run\nthe model update  for each combination of actions, and at least one of the\nexpected results must not be a failure. We must be able to find one (potential)\nway that we reached the output we observed (ie it must\n",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Linearizability",children:"linearize"}),")"]}),"\n",(0,a.jsx)(t.p,{children:"From that error it looks like we are somehow getting back an empty result from\nGet  That should be impossible, and yet here we are. If we look at the\nimplementation it should be easy to spot:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"val w = new FileWriter(f)\nw.write(v)\nw.close()\n"})}),"\n",(0,a.jsx)(t.p,{children:"There is a very small window where we open the file writer and write before\nflushing/closing. And yet hedgehog found it! As a better alternative we could\nwrite to a temporary file, and then rename once the data has been written, which\nshould be atomic."}),"\n",(0,a.jsx)(t.p,{children:"Would we have found that edge-case ourselves with any kind of example or\nproperty testing? I highly doubt it!"}),"\n",(0,a.jsx)(t.h3,{id:"vars",children:"Vars"}),"\n",(0,a.jsxs)(t.p,{children:["One thing I have left-off is probably the most confusing aspect of the hedgehog\nimplementation of state-based testing (it doesn't exist in ScalaCheck for\nexample). This is that we have to deal with something called ",(0,a.jsx)(t.code,{children:"Var"})," and\n",(0,a.jsx)(t.code,{children:"Environment"}),". These are visible in the ",(0,a.jsx)(t.code,{children:"execute"}),", ",(0,a.jsx)(t.code,{children:"update"})," and ",(0,a.jsx)(t.code,{children:"ensure"}),"\nfunctions:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"def execute(env: Environment, i: Input): Either[String, Output]\n\ndef update(s: State, i: Input, o: Var[Output]): State\n\ndef ensure(env: Environment, s0: State, s1: State, i: Input, o: Output): Result\n"})}),"\n",(0,a.jsxs)(t.p,{children:["For the tests we just wrote we actually don't need them, but they are useful in\nmore complex testing scenarios. Please see the ",(0,a.jsx)(t.a,{href:"/scala-hedgehog/docs/guides-state-tutorial-vars",children:"next\ntutorial"})," to learn more."]}),"\n",(0,a.jsx)(t.p,{children:"For now just ignore them, you can still get started and write some reasonable\nproperties like we just did."}),"\n",(0,a.jsx)(t.h2,{id:"resources",children:"Resources"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The gold standard for an introduction to state-based testing is John Hughes","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://www.infoq.com/presentations/testing-techniques-case-study/",children:"https://www.infoq.com/presentations/testing-techniques-case-study/"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://www.youtube.com/watch?v=hXnS_Xjwk2Y",children:"Don't Write Tests"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://teh.id.au/posts/2017/07/15/state-machine-testing/index.html",children:"https://teh.id.au/posts/2017/07/15/state-machine-testing/index.html"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://github.com/qfpl/state-machine-testing-course",children:"https://github.com/qfpl/state-machine-testing-course"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://www.youtube.com/watch?v=owHmYA52SIM",children:"Introduction to stateful property based testing"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://www.youtube.com/watch?v=YhAxC_VI2dc",children:"State-based Testing Tutorial"})}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var a=n(6540);const s={},i=a.createContext(s);function r(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);