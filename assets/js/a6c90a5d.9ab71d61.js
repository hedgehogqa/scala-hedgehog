"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[316],{7474:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>d,toc:()=>o});var a=t(4848),s=t(8453);const i={title:"State-Based Property Testing Tutorial (Part 2 - Vars)",sidebar_position:3,sidebar_label:"State-Based Testing (2)",slug:"/guides-state-tutorial-vars"},r=void 0,d={id:"guides/state-tutorial-vars",title:"State-Based Property Testing Tutorial (Part 2 - Vars)",description:"State-Based Property Testing Tutorial (Part 2 - Vars)",source:"@site/../generated-docs/target/mdoc/guides/state-tutorial-vars.md",sourceDirName:"guides",slug:"/guides-state-tutorial-vars",permalink:"/scala-hedgehog/docs/guides-state-tutorial-vars",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"State-Based Property Testing Tutorial (Part 2 - Vars)",sidebar_position:3,sidebar_label:"State-Based Testing (2)",slug:"/guides-state-tutorial-vars"},sidebar:"tutorialSidebar",previous:{title:"State-Based Testing (1)",permalink:"/scala-hedgehog/docs/guides-state-tutorial"},next:{title:"Migration From ScalaCheck",permalink:"/scala-hedgehog/docs/guides-migration-from-scalacheck"}},l={},o=[{value:"State-Based Property Testing Tutorial (Part 2 - Vars)",id:"state-based-property-testing-tutorial-part-2---vars",level:2},{value:"Follow Along",id:"follow-along",level:2},{value:"The Problem",id:"the-problem",level:2},{value:"Model (take 1)",id:"model-take-1",level:3},{value:"Gen",id:"gen",level:3},{value:"Execute (take 1)",id:"execute-take-1",level:3},{value:"Update",id:"update",level:3},{value:"WTF",id:"wtf",level:3},{value:"Model (take 2)",id:"model-take-2",level:3},{value:"Execute (take 2)",id:"execute-take-2",level:3},{value:"Ensure",id:"ensure",level:3},{value:"Debugging",id:"debugging",level:2},{value:"Resources",id:"resources",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"state-based-property-testing-tutorial-part-2---vars",children:"State-Based Property Testing Tutorial (Part 2 - Vars)"}),"\n",(0,a.jsxs)(n.p,{children:["This tutorial continues on from the ",(0,a.jsx)(n.a,{href:"/scala-hedgehog/docs/guides-state-tutorial",children:"first tutorial"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"follow-along",children:"Follow Along"}),"\n",(0,a.jsx)(n.p,{children:"Please feel to play along and tinker with the code."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"$ ./sbt\n> example/runMain hedgehog.examples.state.CRTest\n"})}),"\n",(0,a.jsx)(n.h2,{id:"the-problem",children:"The Problem"}),"\n",(0,a.jsxs)(n.p,{children:["To start with let's define an interface/abstraction for something we want to\ntest against, part of a basic create/read/update/delete or ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Create,_read,_update_and_delete",children:"CRUD"})," store, which\nI'm calling ",(0,a.jsx)(n.code,{children:"CR"})," as we only support create/read to simplify the example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"trait CR {\n\n  def create(v: String): CRId\n\n  def read(id: CRId): Option[String]\n}\n\ncase class CRId(render: String)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["NOTE: The big difference here from the previous ",(0,a.jsx)(n.code,{children:"KV"})," is that the service is\nreturning it's own identifier instead of being passed on. That has implications\nfor testing the state with Hedgehog, which require something extra..."]}),"\n",(0,a.jsx)(n.h3,{id:"model-take-1",children:"Model (take 1)"}),"\n",(0,a.jsx)(n.p,{children:"Similar to our previous example, this also seems fairly straight forward.\nBut we're about to hit a snag..."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"case class State(map: Map[CRId, String])\n"})}),"\n",(0,a.jsx)(n.p,{children:"And our command input types:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"case class Create(value: String)\ncase class Read(id: CRId)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now let's step throught the ",(0,a.jsx)(n.code,{children:"Command"})," functions for ",(0,a.jsx)(n.code,{children:"create"}),"/",(0,a.jsx)(n.code,{children:"read"})," like\nbefore:"]}),"\n",(0,a.jsx)(n.h3,{id:"gen",children:"Gen"}),"\n",(0,a.jsxs)(n.p,{children:["Generation is fairly typical. Note that we can't really usefully create a\n",(0,a.jsx)(n.code,{children:"Read"})," value until we have at least one value in ",(0,a.jsx)(n.code,{children:"State"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def gen(s: State): Option[Gen[Create]] =\n  Some(for {\n    v <- Gen.string(Gen.ascii, Range.linear(1, 10))\n  } yield Create(v))\n\ndef gen(s: State): Option[Gen[Read]] =\n  s.map.keys.toList match {\n    case Nil =>\n      // We haven't created anything yet\n      None\n    case h :: t =>\n      Some(Gen.element(h, t).map(Read(_)))\n  }\n"})}),"\n",(0,a.jsx)(n.h3,{id:"execute-take-1",children:"Execute (take 1)"}),"\n",(0,a.jsx)(n.p,{children:"So far everything lines up just like before:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def execute(i: Create): Either[String, CRId] =\n  Right(cr.create(i.key, i.value))\n\ndef execute(i: Read): Either[String, Option[String]] =\n  Right(cr.read(i.key))\n"})}),"\n",(0,a.jsx)(n.h3,{id:"update",children:"Update"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def update(s: State, i: Create, o: Var[CRId]): State =\n  s.copy(map = s.map + (o -> i.value))\n\n// There are no side-effects for get, so nothing to do\ndef update(s: State, i: Read): State =\n  s\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Hang on, what's that ",(0,a.jsx)(n.code,{children:"Var[CRid]"})," doing?!? Why isn't it just a concrete ",(0,a.jsx)(n.code,{children:"CRId"}),"?\nThat code doesn't even compile!"]}),"\n",(0,a.jsx)(n.h3,{id:"wtf",children:"WTF"}),"\n",(0,a.jsxs)(n.p,{children:['It turns out that Hedgehog forces a very clear separation for functions that\ncan access the "real world" state, and those that can\'t. The reasons for this\nare a little involved, but the basic idea is that we can generate a full\nsequence of commands up-front, without having called ',(0,a.jsx)(n.code,{children:"execute"}),'. So the\nquestion/problem then becomes, how do we capture the "result" to be used in\n',(0,a.jsx)(n.code,{children:"gen"}),", like we ",(0,a.jsx)(n.em,{children:"need"})," to do for ",(0,a.jsx)(n.code,{children:"read"}),"?"]}),"\n",(0,a.jsxs)(n.p,{children:["This is where ",(0,a.jsx)(n.code,{children:"Var"})," and ",(0,a.jsx)(n.code,{children:"Environment"})," come in. For each ",(0,a.jsx)(n.code,{children:"Command.execute"}),",\nHedgehog allocates a unique ",(0,a.jsx)(n.code,{children:"Name"})," (just a plain old incrementing ",(0,a.jsx)(n.code,{children:"Int"}),"), and\npassed ",(0,a.jsx)(n.em,{children:"that"}),' to the "pure" functions, like ',(0,a.jsx)(n.code,{children:"update"})," and ",(0,a.jsx)(n.code,{children:"gen"}),". It's only when\nwe need the ",(0,a.jsx)(n.em,{children:"concrete"})," values do we get access to the ",(0,a.jsx)(n.code,{children:"Environment"})," to look\nthem up."]}),"\n",(0,a.jsx)(n.p,{children:"Here is the relevant data types, that should hopefully make more sense now?"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"case class Name(value: Int)\n\ncase class Environment(map: Map[Name, Any])\n\ncase class Var[A](name: Name) {\n  def get(env: Env): A =\n    env.map(name)\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"model-take-2",children:"Model (take 2)"}),"\n",(0,a.jsxs)(n.p,{children:["So we will need to tweak our model and input slightly to use ",(0,a.jsx)(n.code,{children:"Var"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"case class State(map: Map[Var[CRId], String])\n\ncase class Read(id: Var[CRId])\n"})}),"\n",(0,a.jsx)(n.h3,{id:"execute-take-2",children:"Execute (take 2)"}),"\n",(0,a.jsxs)(n.p,{children:["So let's try that again. Note that we now use ",(0,a.jsx)(n.code,{children:"Environment"})," in the ",(0,a.jsx)(n.code,{children:"Read"}),"\nversion to ",(0,a.jsx)(n.code,{children:"get"})," the concrete ",(0,a.jsx)(n.code,{children:"CRId"})," returned from ",(0,a.jsx)(n.code,{children:"create"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"def execute(env: Environment, i: Create): Either[String, CRId] =\n  Right(cr.create(i.key, i.value))\n\ndef execute(env: Environment, i: Read): Either[String, Option[String]] =\n  Right(cr.read(i.key.get(env)))\n"})}),"\n",(0,a.jsx)(n.h3,{id:"ensure",children:"Ensure"}),"\n",(0,a.jsxs)(n.p,{children:["This is identical to ",(0,a.jsx)(n.code,{children:"KV"}),", although notice we ",(0,a.jsx)(n.em,{children:"could"})," use ",(0,a.jsx)(n.code,{children:"Environment"})," here if\nwe needed to, unlike ",(0,a.jsx)(n.code,{children:"update"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"// Almost the reverse of update, for side-effect operations we may not observe anything just yet\ndef ensure(env: Environment, s0: State, s1: State, i: Create, o: CRId): Result =\n  Result.success\n\ndef ensure(env: Environment, s0: State, s1: State, i: Read, o: Option[String]): Result =\n  s1.map.get(i.key) ==== o\n"})}),"\n",(0,a.jsx)(n.h2,{id:"debugging",children:"Debugging"}),"\n",(0,a.jsx)(n.p,{children:"Let's look at the output of a failed test again:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",children:"Var(Name(0)) = Create(a)\nVar(Name(1)) = Create(b)\nVar(Name(2)) = Read(Var(Name(0)))\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We can start to see that each command is shown to be assigning the result to a\nnew, unique ",(0,a.jsx)(n.code,{children:"Var"}),". We aren't looking at the ",(0,a.jsx)(n.em,{children:"actual"})," ",(0,a.jsx)(n.code,{children:"CRId"})," values.  Hedgehog\n(currently) can't tell that ",(0,a.jsx)(n.code,{children:"Read"})," doesn't actually return anything (useful)\nand so the ",(0,a.jsx)(n.code,{children:"Unit"})," value is also asigned to a new ",(0,a.jsx)(n.code,{children:"Var"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,a.jsx)(n.p,{children:"Unfortunately there isn't much documentation for this approach at the moment."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"http://www.cse.chalmers.se/~nicsma/papers/finding-race-conditions.pdf",children:"Finding Race Conditions in Erlang with QuickCheck and PULSE"}),"\nHedgehog follows a vague description of this implementation which is mentioned\nin this paper."]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://teh.id.au/posts/2017/07/15/state-machine-testing/index.html#parameterised-actions",children:"State machine testing with Hedgehog"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/scala-hedgehog/docs/guides-haskell-differences#state-vars",children:"Haskell Differences"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>d});var a=t(6540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);